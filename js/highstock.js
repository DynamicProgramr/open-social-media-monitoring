/*
Highstock JS v1.1.5 (2012-03-15)

(c) 2009-2011 Torstein H?nsi

License: www.highcharts.com/license
*/


(function () { function Gb(a, b) { var c; if (!a) { a = {} } for (c in b) { a[c] = b[c] } return a } function Hb() { var a = 0, b = arguments, c = b.length, d = {}; for (; a < c; a++) { d[b[a++]] = b[a] } return d } function Ib(a, b) { return parseInt(a, b || 10) } function Jb(a) { return typeof a === "string" } function Kb(a) { return typeof a === "object" } function Lb(a) { return Object.prototype.toString.call(a) === "[object Array]" } function Mb(a) { return typeof a === "number" } function Nb(a) { return d.log(a) / d.LN10 } function Ob(a) { return d.pow(10, a) } function Pb(a, b) { var c = a.length; while (c--) { if (a[c] === b) { a.splice(c, 1); break } } } function Qb(b) { return b !== a && b !== null } function Rb(a, b, c) { var d, e = "setAttribute", f; if (Jb(b)) { if (Qb(c)) { a[e](b, c) } else if (a && a.getAttribute) { f = a.getAttribute(b) } } else if (Qb(b) && Kb(b)) { for (d in b) { a[e](d, b[d]) } } return f } function Sb(a) { return Lb(a) ? a : [a] } function Tb() { var a = arguments, b, c, d = a.length; for (b = 0; b < d; b++) { c = a[b]; if (typeof c !== "undefined" && c !== null) { return c } } } function Ub(b, c) { if (p) { if (c && c.opacity !== a) { c.filter = "alpha(opacity=" + c.opacity * 100 + ")" } } Gb(b.style, c) } function Vb(a, c, d, e, f) { var g = b.createElement(a); if (c) { Gb(g, c) } if (f) { Ub(g, { padding: 0, border: O, margin: 0 }) } if (d) { Ub(g, d) } if (e) { e.appendChild(g) } return g } function Wb(a, b) { var c = function () { }; c.prototype = new a; Gb(c.prototype, b); return c } function Xb(a, b, c, d) { var e = C.lang, f = a, g = isNaN(b = j(b)) ? 2 : b, h = c === undefined ? e.decimalPoint : c, i = d === undefined ? e.thousandsSep : d, k = f < 0 ? "-" : "", l = String(Ib(f = j(+f || 0).toFixed(g))), m = l.length > 3 ? l.length % 3 : 0; return k + (m ? l.substr(0, m) + i : "") + l.substr(m).replace(/(\d{3})(?=\d)/g, "$1" + i) + (g ? h + j(f - l).toFixed(g).slice(2) : "") } function Yb(a, b) { return (new Array((b || 2) + 1 - String(a).length)).join(0) + a } function Zb(a, b, c, d) { var e, f; c = Tb(c, 1); e = a / c; if (!b) { b = [1, 2, 2.5, 5, 10]; if (d && d.allowDecimals === false) { if (c === 1) { b = [1, 2, 5, 10] } else if (c <= .1) { b = [1 / c] } } } for (f = 0; f < b.length; f++) { a = b[f]; if (e <= (b[f] + (b[f + 1] || b[f])) / 2) { break } } a *= c; return a } function $b(a, b) { var c = b || [[V, [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [W, [1, 2, 5, 10, 15, 30]], [X, [1, 2, 5, 10, 15, 30]], [Y, [1, 2, 3, 4, 6, 8, 12]], [Z, [1, 2]], [$, [1, 2]], [_, [1, 2, 3, 4, 6]], [ab, null]], d = c[c.length - 1], e = G[d[0]], f = d[1], g, h; for (h = 0; h < c.length; h++) { d = c[h]; e = G[d[0]]; f = d[1]; if (c[h + 1]) { var i = (e * f[f.length - 1] + G[c[h + 1][0]]) / 2; if (a <= i) { break } } } if (e === G[ab] && a < 5 * e) { f = [1, 2, 5] } if (e === G[ab] && a < 5 * e) { f = [1, 2, 5] } g = Zb(a / e, f); return { unitRange: e, count: g, unitName: d[0]} } function _b(a, b, c, d) { var e = [], g, h = {}, i = C.global.useUTC, j, k = new Date(b), l = a.unitRange, m = a.count; if (l >= G[W]) { k.setMilliseconds(0); k.setSeconds(l >= G[X] ? 0 : m * f(k.getSeconds() / m)) } if (l >= G[X]) { k[nb](l >= G[Y] ? 0 : m * f(k[hb]() / m)) } if (l >= G[Y]) { k[ob](l >= G[Z] ? 0 : m * f(k[ib]() / m)) } if (l >= G[Z]) { k[pb](l >= G[_] ? 1 : m * f(k[kb]() / m)) } if (l >= G[_]) { k[qb](l >= G[ab] ? 0 : m * f(k[lb]() / m)); j = k[mb]() } if (l >= G[ab]) { j -= j % m; k[rb](j) } if (l === G[$]) { k[pb](k[kb]() - k[jb]() + Tb(d, 1)) } g = 1; j = k[mb](); var n = k.getTime(), o = k[lb](), p = k[kb](); while (n < c) { e.push(n); if (l === G[ab]) { n = gb(j + g * m, 0) } else if (l === G[_]) { n = gb(j, o + g * m) } else if (!i && (l === G[Z] || l === G[$])) { n = gb(j, o, p + g * m * (l === G[Z] ? 1 : 7)) } else { n += l * m; if (l <= G[Y] && n % G[Z] === 0) { h[n] = Z } } g++ } e.push(n); e.info = Gb(a, { higherRanks: h, totalRange: l * m }); return e } function ac() { this.color = 0; this.symbol = 0 } function bc(a, b, c, d, e, f, g, h, i) { var j = g.x, k = g.y, l = j + c + (i ? h : -a - h), m = k - b + d + 15, n; if (l < 7) { l = c + j + h } if (l + a > c + e) { l -= l + a - (c + e); m = k - b + d - h; n = true } if (m < d + 5) { m = d + 5; if (n && k >= m && k <= m + b) { m = k + d + h } } else if (m + b > d + f) { m = d + f - b - h } return { x: l, y: m} } function cc(a, b) { var c = a.length, d, e; for (e = 0; e < c; e++) { a[e].ss_i = e } a.sort(function (a, c) { d = b(a, c); return d === 0 ? a.ss_i - c.ss_i : d }); for (e = 0; e < c; e++) { delete a[e].ss_i } } function dc(a) { var b = a.length, c = a[0]; while (b--) { if (a[b] < c) { c = a[b] } } return c } function ec(a) { var b = a.length, c = a[0]; while (b--) { if (a[b] > c) { c = a[b] } } return c } function fc(a) { var b; for (b in a) { if (a[b] && a[b].destroy) { a[b].destroy() } delete a[b] } } function gc(a) { if (!B) { B = Vb(H) } if (a) { B.appendChild(a) } B.innerHTML = "" } function hc(a, b) { var d = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a; if (b) { throw d } else if (c.console) { console.log(d) } } function ic(a) { return parseFloat(a.toPrecision(14)) } function jc(a, b) { E = Tb(a, b.animation) } function wc() { var a = C.global.useUTC, b = a ? "getUTC" : "get", c = a ? "setUTC" : "set"; gb = a ? Date.UTC : function (a, b, c, d, e, f) { return (new Date(a, b, Tb(c, 1), Tb(d, 0), Tb(e, 0), Tb(f, 0))).getTime() }; hb = b + "Minutes"; ib = b + "Hours"; jb = b + "Day"; kb = b + "Date"; lb = b + "Month"; mb = b + "FullYear"; nb = c + "Minutes"; ob = c + "Hours"; pb = c + "Date"; qb = c + "Month"; rb = c + "FullYear" } function xc(b) { oc = zb(oc, b.xAxis); pc = zb(pc, b.yAxis); b.xAxis = b.yAxis = a; C = zb(C, b); wc(); return C } function yc() { return C } function Ac() { } function Hc(k, l) { function Qc(b) { function gc(a, b) { var c = this; c.pos = a; c.type = b || ""; c.isNew = true; if (!b) { c.addLabel() } } function jc(a) { var b = this; if (a) { b.options = a; b.id = a.id } return b } function mc(a, b, c, d) { var e = this; e.isNegative = b; e.options = a; e.x = c; e.stack = d; e.alignOptions = { align: a.align || (Dc ? b ? "left" : "right" : "center"), verticalAlign: a.verticalAlign || (Dc ? "middle" : b ? "bottom" : "top"), y: Tb(a.y, Dc ? 4 : b ? 14 : -6), x: Tb(a.x, Dc ? b ? -6 : 6 : 0) }; e.textAlign = a.textAlign || (Dc ? b ? "right" : "left" : "center") } function nc() { var b = [], d = [], e; U = V = null; vb(q.series, function (f) { if (f.visible || !o.ignoreHiddenSeries) { var g = f.options, j, k, l, m, q, r, s, t, v, w, x = g.threshold, y, z = [], A = 0; if (u && x <= 0) { x = g.threshold = null } if (c) { s = f.xData; if (s.length) { U = i(Tb(U, s[0]), dc(s)); V = h(Tb(V, s[0]), ec(s)) } } else { var B, C, D, E = f.cropped, F = f.xAxis.getExtremes(), G, H = !!f.modifyValue; j = g.stacking; tb = j === "percent"; if (j) { q = g.stack; m = f.type + Tb(q, ""); r = "-" + m; f.stackKey = m; k = b[m] || []; b[m] = k; l = d[r] || []; d[r] = l } if (tb) { U = 0; V = 99 } s = f.processedXData; t = f.processedYData; y = t.length; for (e = 0; e < y; e++) { v = s[e]; w = t[e]; if (w !== null && w !== a) { if (j) { B = w < x; C = B ? l : k; D = B ? r : m; w = C[v] = Qb(C[v]) ? C[v] + w : w; if (!n[D]) { n[D] = {} } if (!n[D][v]) { n[D][v] = new mc(p.stackLabels, B, v, q) } n[D][v].setTotal(w) } else if (H) { w = f.modifyValue(w) } if (E || (s[e + 1] || v) >= F.min && (s[e - 1] || v) <= F.max) { G = w.length; if (G) { while (G--) { if (w[G] !== null) { z[A++] = w[G] } } } else { z[A++] = w } } } } if (!tb && z.length) { U = i(Tb(U, z[0]), dc(z)); V = h(Tb(V, z[0]), ec(z)) } if (Qb(x)) { if (U >= x) { U = x; rb = true } else if (V < x) { V = x; sb = true } } } } }) } function uc(a, b, c) { var d, e, h = ic(f(b / a) * a), i = ic(g(c / a) * a), j = []; d = h; while (d <= i) { j.push(d); d = ic(d + a); if (d === e) { break } e = d } return j } function vc(a, b, c, g) { var h = []; if (!g) { q._minorAutoInterval = null } if (a >= .5) { a = e(a); h = uc(a, b, c) } else if (a >= .08) { var i = f(b), j, k, l, m, n, o, r; if (a > .3) { j = [1, 2, 4] } else if (a > .15) { j = [1, 2, 4, 6, 8] } else { j = [1, 2, 3, 4, 5, 6, 7, 8, 9] } for (k = i; k < c + 1 && !r; k++) { m = j.length; for (l = 0; l < m && !r; l++) { n = Nb(Ob(k) * j[l]); if (n > b) { h.push(o) } if (o > c) { r = true } o = n } } } else { var s = Ob(b), t = Ob(c), u = p[g ? "minorTickInterval" : "tickInterval"], v = u === "auto" ? null : u, w = p.tickPixelInterval / (g ? 5 : 1), y = g ? x / Hb.length : x; a = Tb(v, q._minorAutoInterval, (t - s) * w / (y || 1)); a = Zb(a, null, d.pow(10, f(d.log(a) / d.LN10))); h = yb(uc(a, s, t), Nb); if (!g) { q._minorAutoInterval = a / 5 } } if (!g) { Db = a } return h } function wc() { var a = [], b, c, d; if (u) { d = Hb.length; for (c = 1; c < d; c++) { a = a.concat(vc(Eb, Hb[c - 1], Hb[c], true)) } } else { for (b = eb + (Hb[0] - eb) % Eb; b <= db; b += Eb) { a.push(b) } } return a } function xc() { var b, d = V - U >= W, e, f, g, h, j, k, l; if (c && W === a && !u) { if (Qb(p.min) || Qb(p.max)) { W = null } else { vb(q.series, function (b) { h = b.xData; j = b.xIncrement ? 1 : h.length - 1; for (f = j; f > 0; f--) { g = h[f] - h[f - 1]; if (e === a || g < e) { e = g } } }); W = i(e * 5, V - U) } } if (db - eb < W) { b = (W - db + eb) / 2; k = [eb - b, Tb(p.min, eb - b)]; if (d) { k[2] = U } eb = ec(k); l = [eb + W, Tb(p.max, eb + W)]; if (d) { l[2] = V } db = dc(l); if (db - eb < W) { k[0] = db - W; k[1] = Tb(p.min, db - W); eb = ec(k) } } } function yc(a) { var b, e, g = p.tickInterval, j = p.tickPixelInterval; if (ob) { qb = pb[c ? "xAxis" : "yAxis"][p.linkedTo]; e = qb.getExtremes(); eb = Tb(e.min, e.dataMin); db = Tb(e.max, e.dataMax); if (p.type !== qb.options.type) { hc(11, 1) } } else { eb = Tb(Z, p.min, U); db = Tb($, p.max, V) } if (u) { if (!a && i(eb, U) <= 0) { hc(10, 1) } eb = Nb(eb); db = Nb(db) } if (X) { Z = eb = h(eb, db - X); $ = db; if (a) { X = null } } xc(); if (!Vb && !tb && !ob && Qb(eb) && Qb(db)) { b = db - eb || 1; if (!Qb(p.min) && !Qb(Z) && lb && (U < 0 || !rb)) { eb -= b * lb } if (!Qb(p.max) && !Qb($) && mb && (V > 0 || !sb)) { db += b * mb } } if (eb === db || eb === undefined || db === undefined) { Db = 1 } else if (ob && !g && j === qb.options.tickPixelInterval) { Db = qb.tickInterval } else { Db = Tb(g, Vb ? 1 : (db - eb) * j / (x || 1)) } if (c && !a) { vb(q.series, function (a) { a.processData(eb !== fb || db !== gb) }) } L(); if (q.beforeSetTickPositions) { q.beforeSetTickPositions() } if (q.postProcessTickInterval) { Db = q.postProcessTickInterval(Db) } if (!t && !u) { Fb = d.pow(10, f(d.log(Db) / d.LN10)); if (!Qb(p.tickInterval)) { Db = Zb(Db, null, Fb, p) } } q.tickInterval = Db; Eb = p.minorTickInterval === "auto" && Db ? Db / 5 : p.minorTickInterval; Hb = p.tickPositions || Jb && Jb.apply(q, [eb, db]); if (!Hb) { if (t) { Hb = (q.getNonLinearTimeTicks || _b)($b(Db, p.units), eb, db, p.startOfWeek, q.ordinalPositions, q.closestPointRange, true) } else if (u) { Hb = vc(Db, eb, db) } else { Hb = uc(Db, eb, db) } } if (!ob) { var k = Hb[0], l = Hb[Hb.length - 1]; if (p.startOnTick) { eb = k } else if (eb > k) { Hb.shift() } if (p.endOnTick) { db = l } else if (db < l) { Hb.pop() } if (!Ac) { Ac = { x: 0, y: 0} } if (!t && Hb.length > Ac[w] && p.alignTicks !== false) { Ac[w] = Hb.length } } } function Bc() { if (Ac && Ac[w] && !t && !Vb && !ob && p.alignTicks !== false) { var a = Rb, b = Hb.length; Rb = Ac[w]; if (b < Rb) { while (Hb.length < Rb) { Hb.push(ic(Hb[Hb.length - 1] + Db)) } z *= (b - 1) / (Rb - 1); db = Hb[Hb.length - 1] } if (Qb(a) && Rb !== a) { q.isDirty = true } } } function Cc() { var a, b, d, e; fb = eb; gb = db; y = x; x = l ? F : G; e = x !== y; vb(q.series, function (a) { if (a.isDirtyData || a.isDirty || a.xAxis.isDirty) { d = true } }); if (e || d || ob || Z !== bb || $ !== cb) { nc(); yc(); bb = Z; cb = $; if (!c) { for (a in n) { for (b in n[a]) { n[a][b].cum = n[a][b].total } } } if (!q.isDirty) { q.isDirty = e || eb !== fb || db !== gb } } } function Fc(a, b, c, d, e) { c = Tb(c, true); e = Gb(e, { min: a, max: b }); Cb(q, "setExtremes", e, function () { Z = a; $ = b; q.isDirtyExtremes = true; if (c) { pb.redraw(d) } }) } function Gc() { var a = p.offsetLeft || 0, b = p.offsetRight || 0; C = Tb(p.left, _ + a); E = Tb(p.top, Y); F = Tb(p.width, kc - a + b); G = Tb(p.height, Yb); H = ib - G - E; I = hb - F - C; x = l ? F : G; q.left = C; q.top = E; q.len = x } function Hc() { return { min: u ? ic(Ob(eb)) : eb, max: u ? ic(Ob(db)) : db, dataMin: U, dataMax: V, userMin: Z, userMax: $} } function Ic(a) { var b = u ? Ob(eb) : eb, c = u ? Ob(db) : db; if (b > a || a === null) { a = b } else if (c < a) { a = c } return J(a, 0, 1, 0, 1) } function Jc(a) { var b = (new jc(a)).render(); xb.push(b); return b } function Kc() { var a = q.series.length && Qb(eb) && Qb(db), b = a || Tb(p.showEmpty, true), c = 0, d, e = 0, f = p.title, g = p.labels, i = [-1, 1, 1, -1][m], j; if (!R) { R = Ec.g("axis").attr({ zIndex: 7 }).add(); S = Ec.g("grid").attr({ zIndex: p.gridZIndex || 1 }).add() } Sb = 0; if (a || ob) { vb(Hb, function (a) { if (!Kb[a]) { Kb[a] = new gc(a) } else { Kb[a].addLabel() } }); vb(Hb, function (a) { if (m === 0 || m === 2 || { 1: "left", 3: "right"}[m] === g.align) { Sb = h(Kb[a].getLabelSize(), Sb) } }); if (ac) { Sb += (ac - 1) * 16 } } else { for (j in Kb) { Kb[j].destroy(); delete Kb[j] } } if (f && f.text) { if (!r) { r = q.axisTitle = Ec.text(f.text, 0, 0, f.useHTML).attr({ zIndex: 7, rotation: f.rotation || 0, align: f.textAlign || { low: "left", middle: "center", high: "right"}[f.align] }).css(f.style).add(); r.isNew = true } if (b) { c = r.getBBox()[l ? "height" : "width"]; e = Tb(f.margin, l ? 5 : 10); d = f.offset } r[b ? "show" : "hide"]() } v = i * Tb(p.offset, ab[m]); Ub = Tb(d, Sb + e + (m !== 2 && Sb && i * p.labels[l ? "y" : "x"])); ab[m] = h(ab[m], Ub + c + i * v) } function Lc() { var b = p.title, c = p.stackLabels, d = p.alternateGridColor, e = p.lineWidth, f, g, h, i = pb.hasRendered, j = i && Qb(fb) && !isNaN(fb), o = q.series.length && Qb(eb) && Qb(db), s = o || Tb(p.showEmpty, true), t, w; if (o || ob) { if (Eb && !Vb) { vb(wc(), function (a) { if (!Lb[a]) { Lb[a] = new gc(a, "minor") } if (j && Lb[a].isNew) { Lb[a].render(null, true) } Lb[a].isActive = true; Lb[a].render() }) } vb(Hb.slice(1).concat([Hb[0]]), function (a, b) { b = b === Hb.length - 1 ? 0 : b + 1; if (!ob || a >= eb && a <= db) { if (!Kb[a]) { Kb[a] = new gc(a) } if (j && Kb[a].isNew) { Kb[a].render(b, true) } Kb[a].isActive = true; Kb[a].render(b) } }); if (d) { vb(Hb, function (b, c) { if (c % 2 === 0 && b < db) { if (!Mb[b]) { Mb[b] = new jc } t = b; w = Hb[c + 1] !== a ? Hb[c + 1] : db; Mb[b].options = { from: u ? Ob(t) : t, to: u ? Ob(w) : w, color: d }; Mb[b].render(); Mb[b].isActive = true } }) } if (!q._addedPlotLB) { vb((p.plotLines || []).concat(p.plotBands || []), function (a) { Jc(a) }); q._addedPlotLB = true } } vb([Kb, Lb, Mb], function (a) { var b; for (b in a) { if (!a[b].isActive) { a[b].destroy(); delete a[b] } else { a[b].isActive = false } } }); if (e) { f = C + (k ? F : 0) + v; g = ib - H - (k ? G : 0) + v; h = Ec.crispLine([P, l ? C : f, l ? g : E, Q, l ? hb - I : f, l ? g : ib - H], e); if (!T) { T = Ec.path(h).attr({ stroke: p.lineColor, "stroke-width": e, zIndex: 7 }).add() } else { T.animate({ d: h }) } T[s ? "show" : "hide"]() } if (r && s) { var y = l ? C : E, z = Ib(b.style.fontSize || 12), A = { low: y + (l ? 0 : x), middle: y + x / 2, high: y + (l ? x : 0)}[b.align], B = (l ? E + G : C) + (l ? 1 : -1) * (k ? -1 : 1) * Ub + (m === 2 ? z : 0); r[r.isNew ? "attr" : "animate"]({ x: l ? A : B + (k ? F : 0) + v + (b.x || 0), y: l ? B - (k ? G : 0) + v : A + (b.y || 0) }); r.isNew = false } if (c && c.enabled) { var D, J, K, L = q.stackTotalGroup; if (!L) { q.stackTotalGroup = L = Ec.g("stack-labels").attr({ visibility: M, zIndex: 6 }).translate(_, Y).add() } for (D in n) { J = n[D]; for (K in J) { J[K].render(L) } } } q.isDirty = false } function Mc(a) { var b = xb.length; while (b--) { if (xb[b].id === a) { xb[b].destroy() } } } function Nc(a, b) { p.title = zb(p.title, a); r = r.destroy(); q.isDirty = true; if (Tb(b, true)) { pb.redraw() } } function Oc() { if (lc.resetTracker) { lc.resetTracker() } Lc(); vb(xb, function (a) { a.render() }); vb(q.series, function (a) { a.isDirty = true }) } function Pc(a, c) { q.categories = b.categories = Vb = a; vb(q.series, function (a) { a.translate(); a.setTooltipPoints(true) }); q.isDirty = true; if (Tb(c, true)) { pb.redraw() } } function Qc() { var a; Bb(q); for (a in n) { fc(n[a]); n[a] = null } if (q.stackTotalGroup) { q.stackTotalGroup = q.stackTotalGroup.destroy() } vb([Kb, Lb, Mb, xb], function (a) { fc(a) }); vb([T, R, S, r], function (a) { if (a) { a.destroy() } }); T = R = S = r = null } var c = b.isX, k = b.opposite, l = Dc ? !c : c, m = l ? k ? 0 : 2 : k ? 1 : 3, n = {}, p = zb(c ? oc : pc, [tc, rc, sc, qc][m], b), q = this, r, s = p.type, t = s === "datetime", u = s === "logarithmic", v = p.offset || 0, w = c ? "x" : "y", x = 0, y, z, A, B, C, E, F, G, H, I, J, L, O, R, S, T, U, V, W = p.minRange || p.maxZoom, X = p.range, Z, $, bb, cb, db = null, eb = null, fb, gb, lb = p.minPadding, mb = p.maxPadding, nb = 0, ob = Qb(p.linkedTo), qb, rb, sb, tb, ub = p.events, wb, xb = [], Db, Eb, Fb, Hb, Jb = p.tickPositioner, Kb = {}, Lb = {}, Mb = {}, Rb, Sb, Ub, Vb = p.categories, Wb = p.labels.formatter || function () { var a = this.value, b = this.dateTimeLabelFormat, c; if (b) { c = D(b, a) } else if (Db % 1e6 === 0) { c = a / 1e6 + "M" } else if (Db % 1e3 === 0) { c = a / 1e3 + "k" } else if (!Vb && a >= 1e3) { c = Xb(a, 0) } else { c = a } return c }, ac = l && p.labels.staggerLines, bc = p.reversed, cc = Vb && p.tickmarkPlacement === "between" ? .5 : 0; gc.prototype = { addLabel: function () { var a = this, b = a.pos, c = p.labels, d, f = Vb && l && Vb.length && !c.step && !c.staggerLines && !c.rotation && kc / Vb.length || !l && kc / 2, g = b === Hb[0], i = b === Hb[Hb.length - 1], j, k = Vb && Qb(Vb[b]) ? Vb[b] : b, m = a.label, n = Hb.info, o; if (t && n) { o = p.dateTimeLabelFormats[n.higherRanks[b] || n.unitName] } a.isFirst = g; a.isLast = i; d = Wb.call({ axis: q, chart: pb, isFirst: g, isLast: i, dateTimeLabelFormat: o, value: u ? ic(Ob(k)) : k }); j = f && { width: h(1, e(f - 2 * (c.padding || 10))) + N }; j = Gb(j, c.style); if (!Qb(m)) { a.label = Qb(d) && c.enabled ? Ec.text(d, 0, 0, c.useHTML).attr({ align: c.align, rotation: c.rotation }).css(j).add(R) : null } else if (m) { m.attr({ text: d }).css(j) } }, getLabelSize: function () { var a = this.label; return a ? (this.labelBBox = a.getBBox())[l ? "height" : "width"] : 0 }, getLabelSides: function () { var a = this.labelBBox, b = p.labels, c = a.width, d = c * { left: 0, center: .5, right: 1}[b.align] - b.x; return [-d, c - d] }, handleOverflow: function (a) { var b = true, c = this.isFirst, d = this.isLast, e = this.label, f = e.x; if (c || d) { var g = this.getLabelSides(), h = g[0], i = g[1], j = pb.plotLeft, k = j + q.len, l = Kb[Hb[a + (c ? 1 : -1)]], m = l && l.label.x + l.getLabelSides()[c ? 0 : 1]; if (c && !bc || d && bc) { if (f + h < j) { f = j - h; if (l && f + i > m) { b = false } } } else { if (f + i > k) { f = k - i; if (l && f + h < m) { b = false } } } e.x = f } return b }, render: function (b, c) { var d = this, e = d.type, f = d.label, g = d.pos, h = p.labels, i = d.gridLine, j = e ? e + "Grid" : "grid", m = e ? e + "Tick" : "tick", n = p[j + "LineWidth"], o = p[j + "LineColor"], q = p[j + "LineDashStyle"], r = p[m + "Length"], s = p[m + "Width"] || 0, t = p[m + "Color"], u = p[m + "Position"], w, x = d.mark, y, B = h.step, D = c && kb || ib, E, F = true, K, L; K = l ? J(g + cc, null, null, c) + A : C + v + (k ? (c && jb || hb) - I - C : 0); L = l ? D - H + v - (k ? G : 0) : D - J(g + cc, null, null, c) - A; if (n) { w = O(g + cc, n, c); if (i === a) { E = { stroke: o, "stroke-width": n }; if (q) { E.dashstyle = q } if (!e) { E.zIndex = 1 } d.gridLine = i = n ? Ec.path(w).attr(E).add(S) : null } if (!c && i && w) { i.animate({ d: w }) } } if (s) { if (u === "inside") { r = -r } if (k) { r = -r } y = Ec.crispLine([P, K, L, Q, K + (l ? 0 : -r), L + (l ? r : 0)], s); if (x) { x.animate({ d: y }) } else { d.mark = Ec.path(y).attr({ stroke: t, "stroke-width": s }).add(R) } } if (f && !isNaN(K)) { K = K + h.x - (cc && l ? cc * z * (bc ? -1 : 1) : 0); L = L + h.y - (cc && !l ? cc * z * (bc ? 1 : -1) : 0); if (!Qb(h.y)) { L += Ib(f.styles.lineHeight) * .9 - f.getBBox().height / 2 } if (ac) { L += b / (B || 1) % ac * 16 } f.x = K; f.y = L; if (d.isFirst && !Tb(p.showFirstLabel, 1) || d.isLast && !Tb(p.showLastLabel, 1)) { F = false } else if (!ac && l && h.overflow === "justify" && !d.handleOverflow(b)) { F = false } if (B && b % B) { F = false } if (F) { f[d.isNew ? "attr" : "animate"]({ x: f.x, y: f.y }); f.show(); d.isNew = false } else { f.hide() } } }, destroy: function () { fc(this) } }; jc.prototype = { render: function () { var a = this, b = (q.pointRange || 0) / 2, c = a.options, d = c.label, e = a.label, f = c.width, g = c.to, j = c.from, k = c.value, m, n = c.dashStyle, o = a.svgElem, p = [], r, s, t, v, w, x, y = c.color, z = c.zIndex, A = c.events, B; if (u) { j = Nb(j); g = Nb(g); k = Nb(k) } if (f) { p = O(k, f); B = { stroke: y, "stroke-width": f }; if (n) { B.dashstyle = n } } else if (Qb(j) && Qb(g)) { j = h(j, eb - b); g = i(g, db + b); m = O(g); p = O(j); if (p && m) { p.push(m[4], m[5], m[1], m[2]) } else { p = null } B = { fill: y} } else { return } if (Qb(z)) { B.zIndex = z } if (o) { if (p) { o.animate({ d: p }, null, o.onGetPath) } else { o.hide(); o.onGetPath = function () { o.show() } } } else if (p && p.length) { a.svgElem = o = Ec.path(p).attr(B).add(); if (A) { r = function (b) { o.on(b, function (c) { A[b].apply(a, [c]) }) }; for (s in A) { r(s) } } } if (d && Qb(d.text) && p && p.length && F > 0 && G > 0) { d = zb({ align: l && m && "center", x: l ? !m && 4 : 10, verticalAlign: !l && m && "middle", y: l ? m ? 16 : 10 : m ? 6 : -4, rotation: l && !m && 90 }, d); if (!e) { a.label = e = Ec.text(d.text, 0, 0).attr({ align: d.textAlign || d.align, rotation: d.rotation, zIndex: z }).css(d.style).add() } t = [p[1], p[4], Tb(p[6], p[1])]; v = [p[2], p[5], Tb(p[7], p[2])]; w = dc(t); x = dc(v); e.align(d, false, { x: w, y: x, width: ec(t) - w, height: ec(v) - x }); e.show() } else if (e) { e.hide() } return a }, destroy: function () { var a = this; fc(a); Pb(xb, a) } }; mc.prototype = { destroy: function () { fc(this) }, setTotal: function (a) { this.total = a; this.cum = a }, render: function (a) { var b = this, c = b.options.formatter.call(b); if (b.label) { b.label.attr({ text: c, visibility: K }) } else { b.label = pb.renderer.text(c, 0, 0).css(b.options.style).attr({ align: b.textAlign, rotation: b.options.rotation, visibility: K }).add(a) } }, setOffset: function (a, b) { var c = this, d = c.isNegative, e = q.translate(c.total, 0, 0, 0, 1), f = q.translate(0), g = j(e - f), h = pb.xAxis[0].translate(c.x) + a, i = pb.plotHeight, k = { x: Dc ? d ? e : e - g : h, y: Dc ? i - h - b : d ? i - e - g : i - e, width: Dc ? g : b, height: Dc ? b : g }; if (c.label) { c.label.align(c.alignOptions, null, k).attr({ visibility: M }) } } }; J = function (a, b, c, d, e) { var f = 1, g = 0, h = d ? B : z, i = d ? fb : eb, j, k = p.ordinal || u && e; if (!h) { h = z } if (c) { f *= -1; g = x } if (bc) { f *= -1; g -= f * x } if (b) { if (bc) { a = x - a } j = a / h + i; if (k) { j = q.lin2val(j) } } else { if (k) { a = q.val2lin(a) } j = f * (a - i) * h + g + f * nb } return j }; O = function (a, b, c) { var d, f, g, h, i = J(a, null, null, c), j = c && kb || ib, k = c && jb || hb, m; d = g = e(i + A); f = h = e(j - i - A); if (isNaN(i)) { m = true } else if (l) { f = E; h = j - H; if (d < C || d > C + F) { m = true } } else { d = C; g = k - I; if (f < E || f > E + G) { m = true } } return m ? null : Ec.crispLine([P, d, f, Q, g, h], b || 0) }; L = function () { var a = db - eb, b = 0, d, e; if (c) { if (ob) { b = qb.pointRange } else { vb(q.series, function (a) { b = h(b, a.pointRange); e = a.closestPointRange; if (!a.noSharedTooltip && Qb(e)) { d = Qb(d) ? i(d, e) : e } }) } q.pointRange = b; q.closestPointRange = d } B = z; q.translationSlope = z = x / (a + b || 1); A = l ? C : H; nb = z * (b / 2) }; zc.push(q); pb[c ? "xAxis" : "yAxis"].push(q); if (Dc && c && bc === a) { bc = true } Gb(q, { addPlotBand: Jc, addPlotLine: Jc, adjustTickAmount: Bc, categories: Vb, getExtremes: Hc, getPlotLinePath: O, getThreshold: Ic, isXAxis: c, options: p, plotLinesAndBands: xb, getOffset: Kc, render: Lc, setAxisSize: Gc, setAxisTranslation: L, setCategories: Pc, setExtremes: Fc, setScale: Cc, setTickPositions: yc, translate: J, redraw: Oc, removePlotBand: Mc, removePlotLine: Mc, reversed: bc, setTitle: Nc, series: [], stacks: n, destroy: Qc }); for (wb in ub) { Ab(q, wb, ub[wb]) } if (u) { q.val2lin = Nb; q.lin2val = Ob } } function Rc(a) { function o() { vb(f, function (a) { if (a) { a.destroy() } }); if (n) { n = n.destroy() } } function p() { var b = this, c = b.points || Sb(b), d = c[0].series, e; e = [d.tooltipHeaderFormatter(c[0].key)]; vb(c, function (a) { d = a.series; e.push(d.tooltipFormatter && d.tooltipFormatter(a) || a.point.tooltipFormatter(d.tooltipOptions.pointFormat)) }); e.push(a.footerFormat || ""); return e.join("") } function q(a, b) { l = k ? a : (2 * l + a) / 3; m = k ? b : (m + b) / 2; n.attr({ x: l, y: m }); if (j(a - l) > 1 || j(b - m) > 1) { Fc = function () { q(a, b) } } else { Fc = null } } function r() { if (!k) { var a = pb.hoverPoints; n.hide(); if (a) { vb(a, function (a) { a.setState() }) } pb.hoverPoints = null; k = true } } function s() { vb(f, function (a) { if (a) { a.hide() } }) } function t(c) { var g, i, j, l, m, o = {}, s, t = [], u = c.tooltipPos, v = a.formatter || p, w = pb.hoverPoints, x, y; if (h && !(c.series && c.series.noSharedTooltip)) { m = 0; if (w) { vb(w, function (a) { a.setState() }) } pb.hoverPoints = c; vb(c, function (a) { a.setState(T); m += a.plotY; t.push(a.getLabelConfig()) }); l = c[0].plotX; m = e(m) / c.length; o = { x: c[0].category }; o.points = t; c = c[0] } else { o = c.getLabelConfig() } s = v.call(o); b = c.series; l = Tb(l, c.plotX); m = Tb(m, c.plotY); g = e(u ? u[0] : Dc ? kc - m : l); i = e(u ? u[1] : Dc ? Yb - l : m); j = h || !b.isCartesian || b.tooltipOutsidePlot || tb(g, i); if (s === false || !j) { r() } else { if (k) { n.show(); k = false } n.attr({ text: s }); y = a.borderColor || c.color || b.color || "#606060"; n.attr({ stroke: y }); x = bc(n.width, n.height, _, Y, kc, Yb, { x: g, y: i }, Tb(a.distance, 12), Dc); q(e(x.x), e(x.y)) } if (d) { d = Sb(d); var z, A = d.length, B, C; while (A--) { C = c.series[A ? "yAxis" : "xAxis"]; if (d[A] && C) { z = C.getPlotLinePath(A ? Tb(c.stackY, c.y) : c.x, 1); if (f[A]) { f[A].attr({ d: z, visibility: M }) } else { B = { "stroke-width": d[A].width || 1, stroke: d[A].color || "#C0C0C0", zIndex: d[A].zIndex || 2 }; if (d[A].dashStyle) { B.dashstyle = d[A].dashStyle } f[A] = Ec.path(z).attr(B).add() } } } } Cb(pb, "tooltipRefresh", { text: s, x: g + _, y: i + Y, borderColor: y }) } var b, c = a.borderWidth, d = a.crosshairs, f = [], g = a.style, h = a.shared, i = Ib(g.padding), k = true, l = 0, m = 0; g.padding = 0; var n = Ec.label("", 0, 0, null, null, null, a.useHTML).attr({ padding: i, fill: a.backgroundColor, "stroke-width": c, r: a.borderRadius, zIndex: 8 }).css(g).hide().add(); if (!w) { n.shadow(a.shadow) } return { shared: h, refresh: t, hide: r, hideCrosshairs: s, destroy: o} } function Sc(a) { function s(a) { var b, d, f, g, h; a = a || c.event; if (!a.target) { a.target = a.srcElement } if (a.originalEvent) { a = a.originalEvent } if (a.event) { a = a.event } b = a.touches ? a.touches.item(0) : a; wc = xb(db); d = wc.left; f = wc.top; if (p) { g = a.x; h = a.y } else { g = b.pageX - d; h = b.pageY - f } return Gb(a, { chartX: e(g), chartY: e(h) }) } function t(a) { var b = { xAxis: [], yAxis: [] }; vb(zc, function (c) { var d = c.translate, e = c.isXAxis, f = Dc ? !e : e; b[e ? "xAxis" : "yAxis"].push({ axis: c, value: d(f ? a.chartX - _ : Yb - a.chartY + Y, true) }) }); return b } function u(b) { var c, d, e = pb.hoverPoint, f = pb.hoverSeries, g, h, k = hb, l = Dc ? b.chartY : b.chartX - _; if (ub && a.shared && !(f && f.noSharedTooltip)) { d = []; g = Cc.length; for (h = 0; h < g; h++) { if (Cc[h].visible && Cc[h].options.enableMouseTracking !== false && !Cc[h].noSharedTooltip && Cc[h].tooltipPoints.length) { c = Cc[h].tooltipPoints[l]; c._dist = j(l - c.plotX); k = i(k, c._dist); d.push(c) } } g = d.length; while (g--) { if (d[g]._dist > k) { d.splice(g, 1) } } if (d.length && d[0].plotX !== Ic) { ub.refresh(d); Ic = d[0].plotX } } if (f && f.tracker) { c = f.tooltipPoints[l]; if (c && c !== e) { c.onMouseOver() } } } function v() { var a = pb.hoverSeries, b = pb.hoverPoint; if (b) { b.onMouseOut() } if (a) { a.onMouseOut() } if (ub) { ub.hide(); ub.hideCrosshairs() } Ic = null } function x() { if (k) { var a = { xAxis: [], yAxis: [] }, c = k.getBBox(), d = c.x - _, e = c.y - Y; if (g) { vb(zc, function (b) { if (b.options.zoomEnabled !== false) { var f = b.translate, g = b.isXAxis, j = Dc ? !g : g, k = f(j ? d : Yb - e - c.height, true, 0, 0, 1), l = f(j ? d + c.width : Yb - e, true, 0, 0, 1); a[g ? "xAxis" : "yAxis"].push({ axis: b, min: i(k, l), max: h(k, l) }) } }); Cb(pb, "selection", a, Oc) } k = k.destroy() } Ub(db, { cursor: "auto" }); pb.mouseIsDown = Hb = g = false; Bb(b, y ? "touchend" : "mouseup", x) } function z(a) { var b = Qb(a.pageX) ? a.pageX : a.page.x, c = Qb(a.pageX) ? a.pageY : a.page.y; if (wc && !tb(b - wc.left - _, c - wc.top - Y)) { v() } } function A() { v(); wc = null } function B() { var a = true; db.onmousedown = function (a) { a = s(a); if (!y && a.preventDefault) { a.preventDefault() } pb.mouseIsDown = Hb = true; pb.mouseDownX = d = a.chartX; f = a.chartY; Ab(b, y ? "touchend" : "mouseup", x) }; var c = function (b) { if (b && b.touches && b.touches.length > 1) { return } b = s(b); if (!y) { b.returnValue = false } var c = b.chartX, e = b.chartY, h = !tb(c - _, e - Y); if (y && b.type === "touchstart") { if (Rb(b.target, "isTracker")) { if (!pb.runTrackerClick) { b.preventDefault() } } else if (!rb && !h) { b.preventDefault() } } if (h) { if (c < _) { c = _ } else if (c > _ + kc) { c = _ + kc } if (e < Y) { e = Y } else if (e > Y + Yb) { e = Y + Yb } } if (Hb && b.type !== "touchstart") { g = Math.sqrt(Math.pow(d - c, 2) + Math.pow(f - e, 2)); if (g > 10) { var i = tb(d - _, f - Y); if (xc && (m || n) && i) { if (!k) { k = Ec.rect(_, Y, q ? 1 : kc, r ? 1 : Yb, 0).attr({ fill: o.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7 }).add() } } if (k && q) { var l = c - d; k.attr({ width: j(l), x: (l > 0 ? 0 : l) + d }) } if (k && r) { var p = e - f; k.attr({ height: j(p), y: (p > 0 ? 0 : p) + f }) } if (i && !k && o.panning) { pb.pan(c) } } } else if (!h) { u(b) } a = h; return h || !xc }; db.onmousemove = c; Ab(db, "mouseleave", A); Ab(b, "mousemove", z); db.ontouchstart = function (a) { if (m || n) { db.onmousedown(a) } c(a) }; db.ontouchmove = c; db.ontouchend = function () { if (g) { v() } }; db.onclick = function (a) { var b = pb.hoverPoint; a = s(a); a.cancelBubble = true; if (!g) { if (b && (Rb(a.target, "isTracker") || Rb(a.target.parentNode, "isTracker"))) { var c = b.plotX, d = b.plotY; Gb(b, { pageX: wc.left + _ + (Dc ? kc - d : c), pageY: wc.top + Y + (Dc ? Yb - c : d) }); Cb(b.series, "click", Gb(a, { point: b })); b.firePointEvent("click", a) } else { Gb(a, t(a)); if (tb(a.chartX - _, a.chartY - Y)) { Cb(pb, "click", a) } } } g = false } } function C() { if (pb.trackerGroup) { pb.trackerGroup = mc = pb.trackerGroup.destroy() } Bb(db, "mouseleave", A); Bb(b, "mousemove", z); db.onclick = db.onmousedown = db.onmousemove = db.ontouchstart = db.ontouchend = db.ontouchmove = null } var d, f, g, k, l = w ? "" : o.zoomType, m = /x/.test(l), n = /y/.test(l), q = m && !Dc || n && Dc, r = n && !Dc || m && Dc; if (!mc) { pb.trackerGroup = mc = Ec.g("tracker").attr({ zIndex: 9 }).add() } if (a.enabled) { pb.tooltip = ub = Rc(a); Hc = setInterval(function () { if (Fc) { Fc() } }, 32) } B(); Gb(this, { zoomX: m, zoomY: n, resetTracker: v, normalizeMouseEvent: s, destroy: C }) } function Uc(a) { var b = a.type || o.type || o.defaultSeriesType, c = Fb[b], d, e = pb.hasRendered; if (e) { if (Dc && b === "column") { c = Fb.bar } else if (!Dc && b === "bar") { c = Fb.column } } d = new c; d.init(pb, a); if (!e && d.inverted) { Dc = true } if (d.isCartesian) { xc = d.isCartesian } Cc.push(d); return d } function Vc(a, b, c) { var d; if (a) { jc(c, pb); b = Tb(b, true); Cb(pb, "addSeries", { options: a }, function () { d = Uc(a); d.isDirty = true; pb.isDirtyLegend = true; if (b) { pb.redraw() } }) } return d } function Wc() { if (o.alignTicks !== false) { vb(zc, function (a) { a.adjustTickAmount() }) } Ac = null } function Xc(a) { var b = pb.isDirtyLegend, c, d = pb.isDirtyBox, e = Cc.length, f = e, g = pb.clipRect, h; jc(a, pb); while (f--) { h = Cc[f]; if (h.isDirty && h.options.stacking) { c = true; break } } if (c) { f = e; while (f--) { h = Cc[f]; if (h.options.stacking) { h.isDirty = true } } } vb(Cc, function (a) { if (a.isDirty) { if (a.options.legendType === "point") { b = true } } }); if (b && nc.renderLegend) { nc.renderLegend(); pb.isDirtyLegend = false } if (xc) { if (!yc) { Ac = null; vb(zc, function (a) { a.setScale() }) } Wc(); Kc(); vb(zc, function (a) { if (a.isDirtyExtremes) { a.isDirtyExtremes = false; Cb(a, "afterSetExtremes", a.getExtremes()) } if (a.isDirty || d) { a.redraw(); d = true } }) } if (d) { Jc(); if (g) { Eb(g); g.animate({ width: pb.plotSizeX, height: pb.plotSizeY + 1 }) } } vb(Cc, function (a) { if (a.isDirty && a.visible && (!a.isCartesian || a.xAxis)) { a.redraw() } }); if (lc && lc.resetTracker) { lc.resetTracker() } Ec.draw(); Cb(pb, "redraw") } function Yc(a) { var b = m.loading; if (!Lb) { Lb = Vb(H, { className: L + "loading" }, Gb(b.style, { left: _ + N, top: Y + N, width: kc + N, height: Yb + N, zIndex: 10, display: O }), db); Mb = Vb("span", null, b.labelStyle, Lb) } Mb.innerHTML = a || m.lang.loading; if (!Wb) { Ub(Lb, { opacity: 0, display: "" }); Db(Lb, { opacity: b.style.opacity }, { duration: b.showDuration || 0 }); Wb = true } } function Zc() { if (Lb) { Db(Lb, { opacity: 0 }, { duration: m.loading.hideDuration || 100, complete: function () { Ub(Lb, { display: O }) } }) } Wb = false } function $c(a) { var b, c, d; for (b = 0; b < zc.length; b++) { if (zc[b].options.id === a) { return zc[b] } } for (b = 0; b < Cc.length; b++) { if (Cc[b].options.id === a) { return Cc[b] } } for (b = 0; b < Cc.length; b++) { d = Cc[b].points || []; for (c = 0; c < d.length; c++) { if (d[c].id === a) { return d[c] } } } return null } function _c() { var a = m.xAxis || {}, b = m.yAxis || {}, c, d; a = Sb(a); vb(a, function (a, b) { a.index = b; a.isX = true }); b = Sb(b); vb(b, function (a, b) { a.index = b }); c = a.concat(b); vb(c, function (a) { d = new Qc(a) }); Wc() } function ad() { var a = []; vb(Cc, function (b) { a = a.concat(wb(b.points, function (a) { return a.selected })) }); return a } function bd() { return wb(Cc, function (a) { return a.selected }) } function cd() { var a = C.lang, b = o.resetZoomButton, c = b.theme, d = c.states, e = b.relativeTo === "chart" ? null : { x: _, y: Y, width: kc, height: Yb }; pb.resetZoomButton = Ec.button(a.resetZoom, null, null, Pc, c, d && d.hover).attr({ align: b.position.align, title: a.resetZoomTitle }).add().align(b.position, false, e) } function dd(a, b) { W = zb(m.title, a); X = zb(m.subtitle, b); vb([["title", a, W], ["subtitle", b, X]], function (a) { var b = a[0], c = pb[b], d = a[1], e = a[2]; if (c && d) { c = c.destroy() } if (e && e.text && !c) { pb[b] = Ec.text(e.text, 0, 0, e.useHTML).attr({ align: e.align, "class": L + b, zIndex: e.zIndex || 4 }).css(e.style).add().align(e, false, V) } }) } function ed() { fb = (cb || bb).offsetWidth; gb = (cb || bb).offsetHeight; pb.chartWidth = hb = o.width || fb || 600; pb.chartHeight = ib = o.height || (gb > 19 ? gb : 400) } function fd() { bb = o.renderTo; eb = L + A++; if (Jb(bb)) { bb = b.getElementById(bb) } if (!bb) { hc(13, true) } bb.innerHTML = ""; if (!bb.offsetWidth) { cb = bb.cloneNode(0); Ub(cb, { position: I, top: "-9999px", display: "" }); b.body.appendChild(cb) } ed(); pb.container = db = Vb(H, { className: L + "container" + (o.className ? " " + o.className : ""), id: eb }, Gb({ position: J, overflow: K, width: hb + N, height: ib + N, textAlign: "left", lineHeight: "normal" }, o.style), cb || bb); pb.renderer = Ec = o.forExport ? new Bc(db, hb, ib, true) : new x(db, hb, ib); if (w) { Ec.create(pb, db, hb, ib) } var a, d; if (s && db.getBoundingClientRect) { a = function () { Ub(db, { left: 0, top: 0 }); d = db.getBoundingClientRect(); Ub(db, { left: -(d.left - Ib(d.left)) + N, top: -(d.top - Ib(d.top)) + N }) }; a(); Ab(c, "resize", a); Ab(pb, "destroy", function () { Bb(c, "resize", a) }) } } function gd() { function d(d) { var e = o.width || bb.offsetWidth, f = o.height || bb.offsetHeight, g = d ? d.target : c; if (e && f && (g === c || g === b)) { if (e !== fb || f !== gb) { clearTimeout(a); a = setTimeout(function () { Nc(e, f, false) }, 100) } fb = e; gb = f } } var a; Ab(c, "resize", d); Ab(pb, "destroy", function () { Bb(c, "resize", d) }) } function hd() { if (pb) { Cb(pb, "endResize", null, function () { yc -= 1 }) } } function id() { var a = "bar", b = Dc || o.inverted || o.type === a || o.defaultSeriesType === a, c = m.series, d = c && c.length; while (!b && d--) { if (c[d].type === a) { b = true } } pb.inverted = Dc = b } function jd() { var a = m.labels, b = m.credits, c; dd(); nc = pb.legend = new Tc; vb(zc, function (a) { a.setScale() }); Kc(); vb(zc, function (a) { a.setTickPositions(true) }); Wc(); Kc(); Jc(); if (xc) { vb(zc, function (a) { a.render() }) } if (!pb.seriesGroup) { pb.seriesGroup = Ec.g("series-group").attr({ zIndex: 3 }).add() } vb(Cc, function (a) { a.translate(); a.setTooltipPoints(); a.render() }); if (a.items) { vb(a.items, function () { var b = Gb(a.style, this.style), c = Ib(b.left) + _, d = Ib(b.top) + Y + 12; delete b.left; delete b.top; Ec.text(this.html, c, d).attr({ zIndex: 2 }).css(b).add() }) } if (b.enabled && !pb.credits) { c = b.href; pb.credits = Ec.text(b.text, 0, 0).on("click", function () { if (c) { location.href = c } }).attr({ align: b.position.align, zIndex: 8 }).css(b.style).add().align(b.position) } pb.hasRendered = true } function kd() { var a, b = db && db.parentNode; if (pb === null) { return } Cb(pb, "destroy"); Bb(pb); a = zc.length; while (a--) { zc[a] = zc[a].destroy() } a = Cc.length; while (a--) { Cc[a] = Cc[a].destroy() } vb(["title", "subtitle", "seriesGroup", "clipRect", "credits", "tracker", "scroller", "rangeSelector"], function (a) { var b = pb[a]; if (b) { pb[a] = b.destroy() } }); vb([lb, ob, mb, nc, ub, Ec, lc], function (a) { if (a && a.destroy) { a.destroy() } }); lb = ob = mb = nc = ub = Ec = lc = null; if (db) { db.innerHTML = ""; Bb(db); if (b) { gc(db) } db = null } clearInterval(Hc); for (a in pb) { delete pb[a] } pb = null; m = null } function ld() { var a = "onreadystatechange", d = "complete"; if (!u && c == c.top && b.readyState !== d || w && !c.canvg) { if (w) { Gc.push(ld, m.global.canvasToolsURL) } else { b.attachEvent(a, function () { b.detachEvent(a, ld); if (b.readyState === d) { ld() } }) } return } fd(); Cb(pb, "init"); if (Highcharts.RangeSelector && m.rangeSelector.enabled) { pb.rangeSelector = new Highcharts.RangeSelector(pb) } Lc(); Mc(); id(); _c(); vb(m.series || [], function (a) { Uc(a) }); if (Highcharts.Scroller && (m.navigator.enabled || m.scrollbar.enabled)) { pb.scroller = new Highcharts.Scroller(pb) } pb.render = jd; pb.tracker = lc = new Sc(m.tooltip); jd(); Ec.draw(); if (l) { l.apply(pb, [pb]) } vb(pb.callbacks, function (a) { a.apply(pb, [pb]) }); if (cb) { bb.appendChild(db); gc(cb) } Cb(pb, "load") } var m, n = k.series; k.series = null; m = zb(C, k); m.series = k.series = n; var o = m.chart, q = o.margin, r = Kb(q) ? q : [q, q, q, q], t = Tb(o.marginTop, r[0]), v = Tb(o.marginRight, r[1]), z = Tb(o.marginBottom, r[2]), B = Tb(o.marginLeft, r[3]), F = o.spacingTop, G = o.spacingRight, R = o.spacingBottom, U = o.spacingLeft, V, W, X, Y, Z, $, _, ab, bb, cb, db, eb, fb, gb, hb, ib, jb, kb, lb, mb, nb, ob, pb = this, qb = o.events, rb = qb && !!qb.click, sb, tb, ub, Hb, Lb, Mb, Wb, Yb, kc, lc, mc, nc, uc, vc, wc, xc = o.showAxes, yc = 0, zc = [], Ac, Cc = [], Dc, Ec, Fc, Hc, Ic, Jc, Kc, Lc, Mc, Nc, Oc, Pc; var Tc = function () { function E(b, c) { var d = b.legendItem, e = b.legendLine, f = b.legendSymbol, g = j.color, h = c ? a.itemStyle.color : g, i = c ? b.color : g; if (d) { d.css({ fill: h }) } if (e) { e.attr({ stroke: i }) } if (f) { f.attr({ stroke: i, fill: i }) } } function G(a) { var b = a.legendItem, c = a.legendLine, d = a._legendItemPos, e = d[0], f = d[1], g = a.legendSymbol, h, i = a.checkbox; if (b) { b.attr({ x: l ? e : uc - e, y: f }) } if (c) { c.translate(l ? e : uc - e, f - 4) } if (g) { h = e + g.xOff; g.attr({ x: l ? h : uc - h, y: f + g.yOff }) } if (i) { i.x = e; i.y = f } } function H(a) { var b = a.checkbox; vb(["legendItem", "legendLine", "legendSymbol"], function (b) { if (a[b]) { a[b].destroy() } }); if (b) { gc(a.checkbox) } } function I() { if (w) { w = w.destroy() } if (z) { z = z.destroy() } } function J() { vb(e, function (a) { var b = a.checkbox, c = z.alignAttr; if (b) { Ub(b, { left: c.translateX + a.legendItemWidth + b.x - 40 + N, top: c.translateY + b.y - 11 + N }) } }) } function K(e) { var f, o, w, x, y, C, D, G = e.legendItem, H = e.series || e, I = H.options, J = I && I.borderWidth || 0; if (!G) { C = /^(bar|pie|area|column)$/.test(H.type); e.legendItem = G = Ec.text(a.labelFormatter.call(e), 0, 0, a.useHTML).css(e.visible ? g : j).on("mouseover", function () { e.setState(T); G.css(i) }).on("mouseout", function () { G.css(e.visible ? g : j); e.setState() }).on("click", function () { var a = "legendItemClick", b = function () { e.setVisible() }; if (e.firePointEvent) { e.firePointEvent(a, null, b) } else { Cb(e, a, null, b) } }).attr({ align: l ? "left" : "right", zIndex: 2 }).add(z); if (!C && I && I.lineWidth) { var K = { "stroke-width": I.lineWidth, zIndex: 2 }; if (I.dashStyle) { K.dashstyle = I.dashStyle } e.legendLine = Ec.path([P, (-c - d) * (l ? 1 : -1), 0, Q, -d * (l ? 1 : -1), 0]).attr(K).add(z) } if (C) { w = Ec.rect(x = -c - d, y = -11, c, 12, 2).attr({ zIndex: 3 }).add(z); if (!l) { x += c } } else if (I && I.marker && I.marker.enabled) { D = I.marker.radius; w = Ec.symbol(e.symbol, x = -c / 2 - d - D, y = -4 - D, 2 * D, 2 * D).attr(e.pointAttr[S]).attr({ zIndex: 3 }).add(z); if (!l) { x += c / 2 } } if (w) { w.xOff = x + J % 2 / 2; w.yOff = y + J % 2 / 2 } e.legendSymbol = w; E(e, e.visible); if (I && I.showCheckbox) { e.checkbox = Vb("input", { type: "checkbox", checked: e.selected, defaultChecked: e.selected }, a.itemCheckboxStyle, db); Ab(e.checkbox, "click", function (a) { var b = a.target; Cb(e, "checkboxClick", { checked: b.checked }, function () { e.select() }) }) } } f = G.getBBox(); o = e.legendItemWidth = a.itemWidth || c + d + f.width + k; v = f.height; if (b && s - q + o > (B || hb - 2 * k - q)) { s = q; t += m + v + n } if (!b && t + a.y + v > ib - F - R) { t = r; s += p; p = 0 } p = h(p, o); u = h(u, t + n); e._legendItemPos = [s, t]; if (b) { s += o } else { t += m + v + n } A = B || h(s - q + (b ? 0 : o), A) } function L() { s = q; t = r; A = 0; u = 0; if (!z) { z = Ec.g("legend").attr({ zIndex: 7 }).add() } e = []; vb(C, function (a) { var b = a.options; if (!b.showInLegend) { return } e = e.concat(a.legendItems || (b.legendType === "point" ? a.data : a)) }); cc(e, function (a, b) { return (a.options.legendIndex || 0) - (b.options.legendIndex || 0) }); if (D) { e.reverse() } vb(e, K); uc = B || A; vc = u - o + v; if (x || y) { uc += 2 * k; vc += 2 * k; if (!w) { w = Ec.rect(0, 0, uc, vc, a.borderRadius, x || 0).attr({ stroke: a.borderColor, "stroke-width": x || 0, fill: y || O }).add(z).shadow(a.shadow); w.isNew = true } else if (uc > 0 && vc > 0) { w[w.isNew ? "attr" : "animate"](w.crisp(null, null, null, uc, vc)); w.isNew = false } w[e.length ? "show" : "hide"]() } vb(e, G); var b = ["left", "right", "top", "bottom"], c, d = 4; while (d--) { c = b[d]; if (f[c] && f[c] !== "auto") { a[d < 2 ? "align" : "verticalAlign"] = c; a[d < 2 ? "x" : "y"] = Ib(f[c]) * (d % 2 ? -1 : 1) } } if (e.length) { z.align(Gb(a, { width: uc, height: vc }), true, V) } if (!yc) { J() } } var a = pb.options.legend; if (!a.enabled) { return } var b = a.layout === "horizontal", c = a.symbolWidth, d = a.symbolPadding, e, f = a.style, g = a.itemStyle, i = a.itemHoverStyle, j = zb(g, a.itemHiddenStyle), k = a.padding || Ib(f.padding), l = !a.rtl, m = a.itemMarginTop || 0, n = a.itemMarginBottom || 0, o = 18, p = 0, q = 4 + k + c + d, r = k + m + o - 5, s, t, u, v = 0, w, x = a.borderWidth, y = a.backgroundColor, z, A, B = a.width, C = pb.series, D = a.reversed; L(); Ab(pb, "endResize", J); return { colorizeItem: E, destroyItem: H, renderLegend: L, destroy: I} }; tb = function (a, b) { return a >= 0 && a <= kc && b >= 0 && b <= Yb }; Pc = function () { var a = pb.resetZoomButton; Cb(pb, "selection", { resetSelection: true }, Oc); if (a) { pb.resetZoomButton = a.destroy() } }; Oc = function (a) { var b; if (pb.resetZoomEnabled !== false && !pb.resetZoomButton) { cd() } if (!a || a.resetSelection) { vb(zc, function (a) { if (a.options.zoomEnabled !== false) { a.setExtremes(null, null, false); b = true } }) } else { vb(a.xAxis.concat(a.yAxis), function (a) { var c = a.axis; if (pb.tracker[c.isXAxis ? "zoomX" : "zoomY"]) { c.setExtremes(a.min, a.max, false); b = true } }) } if (b) { Xc(Tb(o.animation, pb.pointCount < 100)) } }; pb.pan = function (a) { var b = pb.xAxis[0], c = pb.mouseDownX, d = b.pointRange / 2, e = b.getExtremes(), f = b.translate(c - a, true) + d, g = b.translate(c + kc - a, true) - d, j = pb.hoverPoints; if (j) { vb(j, function (a) { a.setState() }) } if (f > i(e.dataMin, e.min) && g < h(e.dataMax, e.max)) { b.setExtremes(f, g, true, false) } pb.mouseDownX = a; Ub(db, { cursor: "move" }) }; Kc = function () { var a = m.legend, b = Tb(a.margin, 10), c = a.x, d = a.y, e = a.align, f = a.verticalAlign, g; Lc(); if ((pb.title || pb.subtitle) && !Qb(t)) { g = h(pb.title && !W.floating && !W.verticalAlign && W.y || 0, pb.subtitle && !X.floating && !X.verticalAlign && X.y || 0); if (g) { Y = h(Y, g + Tb(W.margin, 15) + F) } } if (a.enabled && !a.floating) { if (e === "right") { if (!Qb(v)) { Z = h(Z, uc - c + b + G) } } else if (e === "left") { if (!Qb(B)) { _ = h(_, uc + c + b + U) } } else if (f === "top") { if (!Qb(t)) { Y = h(Y, vc + d + b + F) } } else if (f === "bottom") { if (!Qb(z)) { $ = h($, vc - d + b + R) } } } if (pb.extraBottomMargin) { $ += pb.extraBottomMargin } if (pb.extraTopMargin) { Y += pb.extraTopMargin } if (xc) { vb(zc, function (a) { a.getOffset() }) } if (!Qb(B)) { _ += ab[3] } if (!Qb(t)) { Y += ab[0] } if (!Qb(z)) { $ += ab[2] } if (!Qb(v)) { Z += ab[1] } Mc() }; Nc = function (a, b, c) { var d = pb.title, f = pb.subtitle; yc += 1; jc(c, pb); kb = ib; jb = hb; if (Qb(a)) { pb.chartWidth = hb = e(a) } if (Qb(b)) { pb.chartHeight = ib = e(b) } Ub(db, { width: hb + N, height: ib + N }); Ec.setSize(hb, ib, c); kc = hb - _ - Z; Yb = ib - Y - $; Ac = null; vb(zc, function (a) { a.isDirty = true; a.setScale() }); vb(Cc, function (a) { a.isDirty = true }); pb.isDirtyLegend = true; pb.isDirtyBox = true; Kc(); if (d) { d.align(null, null, V) } if (f) { f.align(null, null, V) } Xc(c); kb = null; Cb(pb, "resize"); if (E === false) { hd() } else { setTimeout(hd, E && E.duration || 500) } }; Mc = function () { pb.plotLeft = _ = e(_); pb.plotTop = Y = e(Y); pb.plotWidth = kc = e(hb - _ - Z); pb.plotHeight = Yb = e(ib - Y - $); pb.plotSizeX = Dc ? Yb : kc; pb.plotSizeY = Dc ? kc : Yb; V = { x: U, y: F, width: hb - U - G, height: ib - F - R }; vb(zc, function (a) { a.setAxisSize(); a.setAxisTranslation() }) }; Lc = function () { Y = Tb(t, F); Z = Tb(v, G); $ = Tb(z, R); _ = Tb(B, U); ab = [0, 0, 0, 0] }; Jc = function () { var a = o.borderWidth || 0, b = o.backgroundColor, c = o.plotBackgroundColor, d = o.plotBackgroundImage, e, f = { x: _, y: Y, width: kc, height: Yb }; e = a + (o.shadow ? 8 : 0); if (a || b) { if (!lb) { lb = Ec.rect(e / 2, e / 2, hb - e, ib - e, o.borderRadius, a).attr({ stroke: o.borderColor, "stroke-width": a, fill: b || O }).add().shadow(o.shadow) } else { lb.animate(lb.crisp(null, null, null, hb - e, ib - e)) } } if (c) { if (!mb) { mb = Ec.rect(_, Y, kc, Yb, 0).attr({ fill: c }).add().shadow(o.plotShadow) } else { mb.animate(f) } } if (d) { if (!nb) { nb = Ec.image(d, _, Y, kc, Yb).add() } else { nb.animate(f) } } if (o.plotBorderWidth) { if (!ob) { ob = Ec.rect(_, Y, kc, Yb, 0, o.plotBorderWidth).attr({ stroke: o.plotBorderColor, "stroke-width": o.plotBorderWidth, zIndex: 4 }).add() } else { ob.animate(ob.crisp(null, _, Y, kc, Yb)) } } pb.isDirtyBox = false }; if (o.reflow !== false) { Ab(pb, "load", gd) } if (qb) { for (sb in qb) { Ab(pb, sb, qb[sb]) } } pb.options = m; pb.series = Cc; pb.xAxis = []; pb.yAxis = []; pb.addSeries = Vc; pb.animation = w ? false : Tb(o.animation, true); pb.Axis = Qc; pb.destroy = kd; pb.get = $c; pb.getSelectedPoints = ad; pb.getSelectedSeries = bd; pb.hideLoading = Zc; pb.initSeries = Uc; pb.isInsidePlot = tb; pb.redraw = Xc; pb.setSize = Nc; pb.setTitle = dd; pb.showLoading = Yc; pb.pointCount = 0; pb.counters = new ac; ld() } var a, b = document, c = window, d = Math, e = d.round, f = d.floor, g = d.ceil, h = d.max, i = d.min, j = d.abs, k = d.cos, l = d.sin, m = d.PI, n = m * 2 / 360, o = navigator.userAgent, p = /msie/i.test(o) && !c.opera, q = b.documentMode === 8, r = /AppleWebKit/.test(o), s = /Firefox/.test(o), t = "http://www.w3.org/2000/svg", u = !!b.createElementNS && !!b.createElementNS(t, "svg").createSVGRect, v = s && parseInt(o.split("Firefox/")[1], 10) < 4, w = !u && !p && !!b.createElement("canvas").getContext, x, y = b.documentElement.ontouchstart !== a, z = {}, A = 0, B, C, D, E, F, G, H = "div", I = "absolute", J = "relative", K = "hidden", L = "highcharts-", M = "visible", N = "px", O = "none", P = "M", Q = "L", R = "rgba(192,192,192," + (u ? 1e-6 : .002) + ")", S = "", T = "hover", U = "select", V = "millisecond", W = "second", X = "minute", Y = "hour", Z = "day", $ = "week", _ = "month", ab = "year", bb = "fill", cb = "linearGradient", db = "stops", eb = "stroke", fb = "stroke-width", gb, hb, ib, jb, kb, lb, mb, nb, ob, pb, qb, rb, sb = c.HighchartsAdapter, tb = sb || {}, ub = tb.getScript, vb = tb.each, wb = tb.grep, xb = tb.offset, yb = tb.map, zb = tb.merge, Ab = tb.addEvent, Bb = tb.removeEvent, Cb = tb.fireEvent, Db = tb.animate, Eb = tb.stop, Fb = {}; c.Highcharts = {}; D = function (a, b, c) { if (!Qb(b) || isNaN(b)) { return "Invalid date" } a = Tb(a, "%Y-%m-%d %H:%M:%S"); var d = new Date(b), f, g = d[ib](), h = d[jb](), i = d[kb](), j = d[lb](), k = d[mb](), l = C.lang, m = l.weekdays, n = { a: m[h].substr(0, 3), A: m[h], d: Yb(i), e: i, b: l.shortMonths[j], B: l.months[j], m: Yb(j + 1), y: k.toString().substr(2, 2), Y: k, H: Yb(g), I: Yb(g % 12 || 12), l: g % 12 || 12, M: Yb(d[hb]()), p: g < 12 ? "AM" : "PM", P: g < 12 ? "am" : "pm", S: Yb(d.getSeconds()), L: Yb(e(b % 1e3), 3) }; for (f in n) { a = a.replace("%" + f, n[f]) } return c ? a.substr(0, 1).toUpperCase() + a.substr(1) : a }; ac.prototype = { wrapColor: function (a) { if (this.color >= a) { this.color = 0 } }, wrapSymbol: function (a) { if (this.symbol >= a) { this.symbol = 0 } } }; G = Hb(V, 1, W, 1e3, X, 6e4, Y, 36e5, Z, 24 * 36e5, $, 7 * 24 * 36e5, _, 30 * 24 * 36e5, ab, 31556952e3); F = { init: function (a, b, c) { b = b || ""; var d = a.shift, e = b.indexOf("C") > -1, f = e ? 7 : 3, g, h, i, j = b.split(" "), k = [].concat(c), l, m, n = function (a) { i = a.length; while (i--) { if (a[i] === P) { a.splice(i + 1, 0, a[i + 1], a[i + 2], a[i + 1], a[i + 2]) } } }; if (e) { n(j); n(k) } if (a.isArea) { l = j.splice(j.length - 6, 6); m = k.splice(k.length - 6, 6) } if (d === 1) { k = [].concat(k).splice(0, f).concat(k) } a.shift = 0; if (j.length) { g = k.length; while (j.length < g) { h = [].concat(j).splice(j.length - f, f); if (e) { h[f - 6] = h[f - 2]; h[f - 5] = h[f - 1] } j = j.concat(h) } } if (l) { j = j.concat(l); k = k.concat(m) } return [j, k] }, step: function (a, b, c, d) { var e = [], f = a.length, g; if (c === 1) { e = d } else if (f === b.length && c < 1) { while (f--) { g = parseFloat(a[f]); e[f] = isNaN(g) ? a[f] : c * parseFloat(b[f] - g) + g } } else { e = b } return e } }; if (sb && sb.init) { sb.init(F) } if (!sb && c.jQuery) { var kc = jQuery; ub = kc.getScript; vb = function (a, b) { var c = 0, d = a.length; for (; c < d; c++) { if (b.call(a[c], a[c], c, a) === false) { return c } } }; wb = kc.grep; yb = function (a, b) { var c = [], d = 0, e = a.length; for (; d < e; d++) { c[d] = b.call(a[d], a[d], d, a) } return c }; zb = function () { var a = arguments; return kc.extend(true, null, a[0], a[1], a[2], a[3]) }; xb = function (a) { return kc(a).offset() }; Ab = function (a, b, c) { kc(a).bind(b, c) }; Bb = function (a, c, d) { var e = b.removeEventListener ? "removeEventListener" : "detachEvent"; if (b[e] && !a[e]) { a[e] = function () { } } kc(a).unbind(c, d) }; Cb = function (a, b, c, d) { var e = kc.Event(b), f = "detached" + b, g; Gb(e, c); if (a[b]) { a[f] = a[b]; a[b] = null } vb(["preventDefault", "stopPropagation"], function (a) { var b = e[a]; e[a] = function () { try { b.call(e) } catch (c) { if (a === "preventDefault") { g = true } } } }); kc(a).trigger(e); if (a[f]) { a[b] = a[f]; a[f] = null } if (d && !e.isDefaultPrevented() && !g) { d(e) } }; Db = function (a, b, c) { var d = kc(a); if (b.d) { a.toD = b.d; b.d = 1 } d.stop(); d.animate(b, c) }; Eb = function (a) { kc(a).stop() }; kc.extend(kc.easing, { easeOutQuad: function (a, b, c, d, e) { return -d * (b /= e) * (b - 2) + c } }); var lc = jQuery.fx, mc = lc.step; vb(["cur", "_default", "width", "height"], function (a, b) { var c = b ? mc : lc.prototype, d = c[a], e; if (d) { c[a] = function (a) { a = b ? a : this; e = a.elem; return e.attr ? e.attr(a.prop, a.now) : d.apply(this, arguments) } } }); mc.d = function (a) { var b = a.elem; if (!a.started) { var c = F.init(b, b.d, b.toD); a.start = c[0]; a.end = c[1]; a.started = true } b.attr("d", F.step(a.start, a.end, a.pos, b.toD)) } } var nc = { enabled: true, align: "center", x: 0, y: 15, style: { color: "#666", fontSize: "11px", lineHeight: "14px"} }; C = { colors: ["#4572A7", "#AA4643", "#89A54E", "#80699B", "#3D96AE", "#DB843D", "#92A8CD", "#A47D7C", "#B5CA92"], symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], decimalPoint: ".", resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: "," }, global: { useUTC: true, canvasToolsURL: "http://code.highcharts.com/stock/1.1.5/modules/canvas-tools.js" }, chart: { borderColor: "#4572A7", borderRadius: 5, defaultSeriesType: "line", ignoreHiddenSeries: true, spacingTop: 10, spacingRight: 10, spacingBottom: 15, spacingLeft: 10, style: { fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', fontSize: "12px" }, backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: { theme: { zIndex: 20 }, position: { align: "right", x: -10, y: 10}} }, title: { text: "Chart title", align: "center", y: 15, style: { color: "#3E576F", fontSize: "16px"} }, subtitle: { text: "", align: "center", y: 30, style: { color: "#6D869F"} }, plotOptions: { line: { allowPointSelect: false, showCheckbox: false, animation: { duration: 1e3 }, events: {}, lineWidth: 2, shadow: true, marker: { enabled: true, lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: { hover: {}, select: { fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2}} }, point: { events: {} }, dataLabels: zb(nc, { enabled: false, y: -6, formatter: function () { return this.y } }), cropThreshold: 300, pointRange: 0, showInLegend: true, states: { hover: { marker: {} }, select: { marker: {}} }, stickyTracking: true} }, labels: { style: { position: I, color: "#3E576F"} }, legend: { enabled: true, align: "center", layout: "horizontal", labelFormatter: function () { return this.name }, borderWidth: 1, borderColor: "#909090", borderRadius: 5, shadow: false, style: { padding: "5px" }, itemStyle: { cursor: "pointer", color: "#3E576F" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#C0C0C0" }, itemCheckboxStyle: { position: I, width: "13px", height: "13px" }, symbolWidth: 16, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0 }, loading: { labelStyle: { fontWeight: "bold", position: J, top: "1em" }, style: { position: I, backgroundColor: "white", opacity: .5, textAlign: "center"} }, tooltip: { enabled: true, backgroundColor: "rgba(255, 255, 255, .85)", borderWidth: 2, borderRadius: 5, headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>', pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>', shadow: true, shared: w, snap: y ? 25 : 10, style: { color: "#333333", fontSize: "12px", padding: "5px", whiteSpace: "nowrap"} }, credits: { enabled: true, text: "Highcharts.com", href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#909090", fontSize: "10px"}} }; var oc = { dateTimeLabelFormats: Hb(V, "%H:%M:%S.%L", W, "%H:%M:%S", X, "%H:%M", Y, "%H:%M", Z, "%e. %b", $, "%e. %b", _, "%b '%y", ab, "%Y"), endOnTick: false, gridLineColor: "#C0C0C0", labels: nc, lineColor: "#C0D0E0", lineWidth: 1, max: null, min: null, minPadding: .01, maxPadding: .01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: false, tickColor: "#C0D0E0", tickLength: 5, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", tickWidth: 1, title: { align: "middle", style: { color: "#6D869F", fontWeight: "bold"} }, type: "linear" }, pc = zb(oc, { endOnTick: true, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: true, labels: { align: "right", x: -8, y: 3 }, lineWidth: 0, maxPadding: .05, minPadding: .05, startOnTick: true, tickWidth: 0, title: { rotation: 270, text: "Y-values" }, stackLabels: { enabled: false, formatter: function () { return this.total }, style: nc.style} }), qc = { labels: { align: "right", x: -8, y: null }, title: { rotation: 270} }, rc = { labels: { align: "left", x: 8, y: null }, title: { rotation: 90} }, sc = { labels: { align: "center", x: 0, y: 14, overflow: "justify" }, title: { rotation: 0} }, tc = zb(sc, { labels: { y: -5, overflow: "justify"} }); var uc = C.plotOptions, vc = uc.line; uc.spline = zb(vc); uc.scatter = zb(vc, { lineWidth: 0, states: { hover: { lineWidth: 0} }, tooltip: { headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"} }); uc.area = zb(vc, { threshold: 0 }); uc.areaspline = zb(uc.area); uc.column = zb(vc, { borderColor: "#FFFFFF", borderWidth: 1, borderRadius: 0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { brightness: .1, shadow: false }, select: { color: "#C0C0C0", borderColor: "#000000", shadow: false} }, dataLabels: { y: null, verticalAlign: null }, threshold: 0 }); uc.bar = zb(uc.column, { dataLabels: { align: "left", x: 5, y: null, verticalAlign: "middle"} }); uc.pie = zb(vc, { borderColor: "#FFFFFF", borderWidth: 1, center: ["50%", "50%"], colorByPoint: true, dataLabels: { distance: 30, enabled: true, formatter: function () { return this.point.name }, y: 5 }, legendType: "point", marker: null, size: "75%", showInLegend: false, slicedOffset: 10, states: { hover: { brightness: .1, shadow: false}} }); wc(); var zc = function (a) { function d(a) { c = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(a); if (c) { b = [Ib(c[1]), Ib(c[2]), Ib(c[3]), parseFloat(c[4], 10)] } else { c = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(a); if (c) { b = [Ib(c[1], 16), Ib(c[2], 16), Ib(c[3], 16), 1] } } } function e(c) { var d; if (b && !isNaN(b[0])) { if (c === "rgb") { d = "rgb(" + b[0] + "," + b[1] + "," + b[2] + ")" } else if (c === "a") { d = b[3] } else { d = "rgba(" + b.join(",") + ")" } } else { d = a } return d } function f(a) { if (Mb(a) && a !== 0) { var c; for (c = 0; c < 3; c++) { b[c] += Ib(a * 255); if (b[c] < 0) { b[c] = 0 } if (b[c] > 255) { b[c] = 255 } } } return this } function g(a) { b[3] = a; return this } var b = [], c; d(a); return { get: e, brighten: f, setOpacity: g} }; Ac.prototype = { init: function (a, c) { var d = this; d.element = c === "span" ? Vb(c) : b.createElementNS(t, c); d.renderer = a; d.attrSetters = {} }, animate: function (a, b, c) { var d = Tb(b, E, true); Eb(this); if (d) { d = zb(d); if (c) { d.complete = c } Db(this, a, d) } else { this.attr(a); if (c) { c() } } }, attr: function (c, d) { var e = this, f, g, h, i, j, k = e.element, l = k.nodeName, m = e.renderer, n, p = e.attrSetters, q = e.shadows, s, u = e; if (Jb(c) && Qb(d)) { f = c; c = {}; c[f] = d } if (Jb(c)) { f = c; if (l === "circle") { f = { x: "cx", y: "cy"}[f] || f } else if (f === "strokeWidth") { f = "stroke-width" } u = Rb(k, f) || e[f] || 0; if (f !== "d" && f !== "visibility") { u = parseFloat(u) } } else { for (f in c) { n = false; g = c[f]; h = p[f] && p[f](g, f); if (h !== false) { if (h !== a) { g = h } if (f === "d") { if (g && g.join) { g = g.join(" ") } if (/(NaN| {2}|^$)/.test(g)) { g = "M 0 0" } e.d = g } else if (f === "x" && l === "text") { for (i = 0; i < k.childNodes.length; i++) { j = k.childNodes[i]; if (Rb(j, "x") === Rb(k, "x")) { Rb(j, "x", g) } } if (e.rotation) { Rb(k, "transform", "rotate(" + e.rotation + " " + g + " " + Ib(c.y || Rb(k, "y")) + ")") } } else if (f === "fill") { g = m.color(g, k, f) } else if (l === "circle" && (f === "x" || f === "y")) { f = { x: "cx", y: "cy"}[f] || f } else if (l === "rect" && f === "r") { Rb(k, { rx: g, ry: g }); n = true } else if (f === "translateX" || f === "translateY" || f === "rotation" || f === "verticalAlign") { e[f] = g; e.updateTransform(); n = true } else if (f === "stroke") { g = m.color(g, k, f) } else if (f === "dashstyle") { f = "stroke-dasharray"; g = g && g.toLowerCase(); if (g === "solid") { g = O } else if (g) { g = g.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); i = g.length; while (i--) { g[i] = Ib(g[i]) * c["stroke-width"] } g = g.join(",") } } else if (f === "isTracker") { e[f] = g } else if (f === "width") { g = Ib(g) } else if (f === "align") { f = "text-anchor"; g = { left: "start", center: "middle", right: "end"}[g] } else if (f === "title") { var v = b.createElementNS(t, "title"); v.appendChild(b.createTextNode(g)); k.appendChild(v) } if (f === "strokeWidth") { f = "stroke-width" } if (r && f === "stroke-width" && g === 0) { g = 1e-6 } if (e.symbolName && /^(x|y|r|start|end|innerR|anchorX|anchorY)/.test(f)) { if (!s) { e.symbolAttr(c); s = true } n = true } if (q && /^(width|height|visibility|x|y|d|transform)$/.test(f)) { i = q.length; while (i--) { Rb(q[i], f, g) } } if ((f === "width" || f === "height") && l === "rect" && g < 0) { g = 0 } if (f === "text") { e.textStr = g; if (e.added) { m.buildText(e) } } else if (!n) { Rb(k, f, g) } } } } if (r && /Chrome\/(18|19)/.test(o)) { if (l === "text" && (c.x !== a || c.y !== a)) { var w = k.parentNode, x = k.nextSibling; if (w) { w.removeChild(k); if (x) { w.insertBefore(k, x) } else { w.appendChild(k) } } } } return u }, symbolAttr: function (a) { var b = this; vb(["x", "y", "r", "start", "end", "width", "height", "innerR", "anchorX", "anchorY"], function (c) { b[c] = Tb(a[c], b[c]) }); b.attr({ d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b) }) }, clip: function (a) { return this.attr("clip-path", "url(" + this.renderer.url + "#" + a.id + ")") }, crisp: function (a, b, c, d, g) { var h = this, i, j = {}, k = {}, l; a = a || h.strokeWidth || h.attr && h.attr("stroke-width") || 0; l = e(a) % 2 / 2; k.x = f(b || h.x || 0) + l; k.y = f(c || h.y || 0) + l; k.width = f((d || h.width || 0) - 2 * l); k.height = f((g || h.height || 0) - 2 * l); k.strokeWidth = a; for (i in k) { if (h[i] !== k[i]) { h[i] = j[i] = k[i] } } return j }, css: function (a) { var b = this, c = b.element, d = a && a.width && c.nodeName === "text", e, f = "", g = function (a, b) { return "-" + b.toLowerCase() }; if (a && a.color) { a.fill = a.color } a = Gb(b.styles, a); b.styles = a; if (p && !u) { if (d) { delete a.width } Ub(b.element, a) } else { for (e in a) { f += e.replace(/([A-Z])/g, g) + ":" + a[e] + ";" } b.attr({ style: f }) } if (d && b.added) { b.renderer.buildText(b) } return b }, on: function (a, b) { var c = b; if (y && a === "click") { a = "touchstart"; c = function (a) { a.preventDefault(); b() } } this.element["on" + a] = c; return this }, translate: function (a, b) { return this.attr({ translateX: a, translateY: b }) }, invert: function () { var a = this; a.inverted = true; a.updateTransform(); return a }, htmlCss: function (a) { var b = this, c = b.element, d = a && c.tagName === "SPAN" && a.width; if (d) { delete a.width; b.textWidth = d; b.updateTransform() } b.styles = Gb(b.styles, a); Ub(b.element, a); return b }, htmlGetBBox: function (a) { var b = this, c = b.element, d = b.bBox; if (!d || a) { if (c.nodeName === "text") { c.style.position = I } d = b.bBox = { x: c.offsetLeft, y: c.offsetTop, width: c.offsetWidth, height: c.offsetHeight} } return d }, htmlUpdateTransform: function () { if (!this.added) { this.alignOnAdd = true; return } var a = this, b = a.renderer, c = a.element, d = a.translateX || 0, e = a.translateY || 0, f = a.x || 0, g = a.y || 0, h = a.textAlign || "left", i = { left: 0, center: .5, right: 1}[h], j = h && h !== "left", m = a.shadows; if (d || e) { Ub(c, { marginLeft: d, marginTop: e }); if (m) { vb(m, function (a) { Ub(a, { marginLeft: d + 1, marginTop: e + 1 }) }) } } if (a.inverted) { vb(c.childNodes, function (a) { b.invertChild(a, c) }) } if (c.tagName === "SPAN") { var o, p, q = a.rotation, r, s = 0, t = 1, u = 0, v, w = Ib(a.textWidth), x = a.xCorr || 0, y = a.yCorr || 0, z = [q, h, c.innerHTML, a.textWidth].join(","); if (z !== a.cTT) { if (Qb(q)) { s = q * n; t = k(s); u = l(s); Ub(c, { filter: q ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", t, ", M12=", -u, ", M21=", u, ", M22=", t, ", sizingMethod='auto expand')"].join("") : O }) } o = Tb(a.elemWidth, c.offsetWidth); p = Tb(a.elemHeight, c.offsetHeight); if (o > w) { Ub(c, { width: w + N, display: "block", whiteSpace: "normal" }); o = w } r = b.fontMetrics(c.style.fontSize).b; x = t < 0 && -o; y = u < 0 && -p; v = t * u < 0; x += u * r * (v ? 1 - i : i); y -= t * r * (q ? v ? i : 1 - i : 1); if (j) { x -= o * i * (t < 0 ? -1 : 1); if (q) { y -= p * i * (u < 0 ? -1 : 1) } Ub(c, { textAlign: h }) } a.xCorr = x; a.yCorr = y } Ub(c, { left: f + x + N, top: g + y + N }); a.cTT = z } }, updateTransform: function () { var a = this, b = a.translateX || 0, c = a.translateY || 0, d = a.inverted, e = a.rotation, f = []; if (d) { b += a.attr("width"); c += a.attr("height") } if (b || c) { f.push("translate(" + b + "," + c + ")") } if (d) { f.push("rotate(90) scale(-1,1)") } else if (e) { f.push("rotate(" + e + " " + a.x + " " + a.y + ")") } if (f.length) { Rb(a.element, "transform", f.join(" ")) } }, toFront: function () { var a = this.element; a.parentNode.appendChild(a); return this }, align: function (a, b, c) { var d = this; if (!a) { a = d.alignOptions; b = d.alignByTranslate } else { d.alignOptions = a; d.alignByTranslate = b; if (!c) { d.renderer.alignedObjects.push(d) } } c = Tb(c, d.renderer); var f = a.align, g = a.verticalAlign, h = (c.x || 0) + (a.x || 0), i = (c.y || 0) + (a.y || 0), j = {}; if (/^(right|center)$/.test(f)) { h += (c.width - (a.width || 0)) / { right: 1, center: 2}[f] } j[b ? "translateX" : "x"] = e(h); if (/^(bottom|middle)$/.test(g)) { i += (c.height - (a.height || 0)) / ({ bottom: 1, middle: 2}[g] || 1) } j[b ? "translateY" : "y"] = e(i); d[d.placed ? "animate" : "attr"](j); d.placed = true; d.alignAttr = j; return d }, getBBox: function (a) { var b = this, c, d, e, f = b.rotation, g = b.element, h = f * n; if (g.namespaceURI === t) { try { c = g.getBBox ? Gb({}, g.getBBox()) : { width: g.offsetWidth, height: g.offsetHeight} } catch (i) { } if (!c || c.width < 0) { c = { width: 0, height: 0} } d = c.width; e = c.height; if (f) { c.width = j(e * l(h)) + j(d * k(h)); c.height = j(e * k(h)) + j(d * l(h)) } } else { c = b.htmlGetBBox(a) } return c }, show: function () { return this.attr({ visibility: M }) }, hide: function () { return this.attr({ visibility: K }) }, add: function (a) { var b = this.renderer, c = a || b, d = c.element || b.box, e = d.childNodes, f = this.element, g = Rb(f, "zIndex"), h, i, j, k; this.parentInverted = a && a.inverted; if (this.textStr !== undefined) { b.buildText(this) } if (g) { c.handleZ = true; g = Ib(g) } if (c.handleZ) { for (j = 0; j < e.length; j++) { h = e[j]; i = Rb(h, "zIndex"); if (h !== f && (Ib(i) > g || !Qb(g) && Qb(i))) { d.insertBefore(f, h); k = true; break } } } if (!k) { d.appendChild(f) } this.added = true; Cb(this, "add"); return this }, safeRemoveChild: function (a) { var b = a.parentNode; if (b) { b.removeChild(a) } }, destroy: function () { var a = this, b = a.element || {}, c = a.shadows, d = a.box, e, f; b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = null; Eb(a); if (a.clipPath) { a.clipPath = a.clipPath.destroy() } if (a.stops) { for (f = 0; f < a.stops.length; f++) { a.stops[f] = a.stops[f].destroy() } a.stops = null } a.safeRemoveChild(b); if (c) { vb(c, function (b) { a.safeRemoveChild(b) }) } if (d) { d.destroy() } Pb(a.renderer.alignedObjects, a); for (e in a) { delete a[e] } return null }, empty: function () { var a = this.element, b = a.childNodes, c = b.length; while (c--) { a.removeChild(b[c]) } }, shadow: function (a, b) { var c = [], d, e, f = this.element, g = this.parentInverted ? "(-1,-1)" : "(1,1)"; if (a) { for (d = 1; d <= 3; d++) { e = f.cloneNode(0); Rb(e, { isShadow: "true", stroke: "rgb(0, 0, 0)", "stroke-opacity": .05 * d, "stroke-width": 7 - 2 * d, transform: "translate" + g, fill: O }); if (b) { b.element.appendChild(e) } else { f.parentNode.insertBefore(e, f) } c.push(e) } this.shadows = c } return this } }; var Bc = function () { this.init.apply(this, arguments) }; Bc.prototype = { Element: Ac, init: function (a, b, c, d) { var e = this, f = location, g; g = e.createElement("svg").attr({ xmlns: t, version: "1.1" }); a.appendChild(g.element); e.isSVG = true; e.box = g.element; e.boxWrapper = g; e.alignedObjects = []; e.url = p ? "" : f.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1"); e.defs = this.createElement("defs").add(); e.forExport = d; e.gradients = {}; e.setSize(b, c, false) }, destroy: function () { var a = this, b = a.defs; a.box = null; a.boxWrapper = a.boxWrapper.destroy(); fc(a.gradients || {}); a.gradients = null; if (b) { a.defs = b.destroy() } a.alignedObjects = null; return null }, createElement: function (a) { var b = new this.Element; b.init(this, a); return b }, draw: function () { }, buildText: function (a) { var d = a.element, e = Tb(a.textStr, "").toString().replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g), f = d.childNodes, g = /style="([^"]+)"/, h = /href="([^"]+)"/, i = Rb(d, "x"), j = a.styles, k = j && Ib(j.width), l = j && j.lineHeight, m, n = "getComputedStyle", o = f.length; while (o--) { d.removeChild(f[o]) } if (k && !a.added) { this.box.appendChild(d) } if (e[e.length - 1] === "") { e.pop() } vb(e, function (e, f) { var j, o = 0, p; e = e.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"); j = e.split("|||"); vb(j, function (e) { if (e !== "" || j.length === 1) { var q = {}, r = b.createElementNS(t, "tspan"); if (g.test(e)) { Rb(r, "style", e.match(g)[1].replace(/(;| |^)color([ :])/, "$1fill$2")) } if (h.test(e)) { Rb(r, "onclick", 'location.href="' + e.match(h)[1] + '"'); Ub(r, { cursor: "pointer" }) } e = (e.replace(/<(.|\n)*?>/g, "") || " ").replace(/</g, "<").replace(/>/g, ">"); r.appendChild(b.createTextNode(e)); if (!o) { q.x = i } else { q.dx = 3 } if (!o) { if (f) { if (!u && a.renderer.forExport) { Ub(r, { display: "block" }) } p = c[n] && Ib(c[n](m, null).getPropertyValue("line-height")); if (!p || isNaN(p)) { p = l || m.offsetHeight || 18 } Rb(r, "dy", p) } m = r } Rb(r, q); d.appendChild(r); o++; if (k) { var s = e.replace(/-/g, "- ").split(" "), v, w, x = []; while (s.length || x.length) { w = a.getBBox().width; v = w > k; if (!v || s.length === 1) { s = x; x = []; if (s.length) { r = b.createElementNS(t, "tspan"); Rb(r, { dy: l || 16, x: i }); d.appendChild(r); if (w > k) { k = w } } } else { r.removeChild(r.firstChild); x.unshift(s.pop()) } if (s.length) { r.appendChild(b.createTextNode(s.join(" ").replace(/- /g, "-"))) } } } } }) }) }, button: function (a, b, c, d, e, f, g) { var h = this.label(a, b, c), i = 0, j, k, l, m, n, o = "style", p = { x1: 0, y1: 0, x2: 0, y2: 1 }; e = zb(Hb(fb, 1, eb, "#999", bb, Hb(cb, p, db, [[0, "#FFF"], [1, "#DDD"]]), "r", 3, "padding", 3, o, Hb("color", "black")), e); l = e[o]; delete e[o]; f = zb(e, Hb(eb, "#68A", bb, Hb(cb, p, db, [[0, "#FFF"], [1, "#ACF"]])), f); m = f[o]; delete f[o]; g = zb(e, Hb(eb, "#68A", bb, Hb(cb, p, db, [[0, "#9BD"], [1, "#CDF"]])), g); n = g[o]; delete g[o]; Ab(h.element, "mouseenter", function () { h.attr(f).css(m) }); Ab(h.element, "mouseleave", function () { j = [e, f, g][i]; k = [l, m, n][i]; h.attr(j).css(k) }); h.setState = function (a) { i = a; if (!a) { h.attr(e).css(l) } else if (a === 2) { h.attr(g).css(n) } }; return h.on("click", function () { d.call(h) }).attr(e).css(Gb({ cursor: "default" }, l)) }, crispLine: function (a, b) { if (a[1] === a[4]) { a[1] = a[4] = e(a[1]) + b % 2 / 2 } if (a[2] === a[5]) { a[2] = a[5] = e(a[2]) + b % 2 / 2 } return a }, path: function (a) { return this.createElement("path").attr({ d: a, fill: O }) }, circle: function (a, b, c) { var d = Kb(a) ? a : { x: a, y: b, r: c }; return this.createElement("circle").attr(d) }, arc: function (a, b, c, d, e, f) { if (Kb(a)) { b = a.y; c = a.r; d = a.innerR; e = a.start; f = a.end; a = a.x } return this.symbol("arc", a || 0, b || 0, c || 0, c || 0, { innerR: d || 0, start: e || 0, end: f || 0 }) }, rect: function (a, b, c, d, e, f) { if (Kb(a)) { b = a.y; c = a.width; d = a.height; e = a.r; f = a.strokeWidth; a = a.x } var g = this.createElement("rect").attr({ rx: e, ry: e, fill: O }); return g.attr(g.crisp(f, a, b, h(c, 0), h(d, 0))) }, setSize: function (a, b, c) { var d = this, e = d.alignedObjects, f = e.length; d.width = a; d.height = b; d.boxWrapper[Tb(c, true) ? "animate" : "attr"]({ width: a, height: b }); while (f--) { e[f].align() } }, g: function (a) { var b = this.createElement("g"); return Qb(a) ? b.attr({ "class": L + a }) : b }, image: function (a, b, c, d, e) { var f = { preserveAspectRatio: O }, g; if (arguments.length > 1) { Gb(f, { x: b, y: c, width: d, height: e }) } g = this.createElement("image").attr(f); if (g.element.setAttributeNS) { g.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) } else { g.element.setAttribute("hc-svg-href", a) } return g }, symbol: function (a, b, c, d, f, g) { var h, i = this.symbols[a], j = i && i(e(b), e(c), d, f, g), k = /^url\((.*?)\)$/, l, m; if (j) { h = this.path(j); Gb(h, { symbolName: a, x: b, y: c, width: d, height: f }); if (g) { Gb(h, g) } } else if (k.test(a)) { var n = function (a, b) { a.attr({ width: b[0], height: b[1] }).translate(-e(b[0] / 2), -e(b[1] / 2)) }; l = a.match(k)[1]; m = z[l]; h = this.image(l).attr({ x: b, y: c }); if (m) { n(h, m) } else { h.attr({ width: 0, height: 0 }); Vb("img", { onload: function () { var a = this; n(h, z[l] = [a.width, a.height]) }, src: l }) } } return h }, symbols: { circle: function (a, b, c, d) { var e = .166 * c; return [P, a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"] }, square: function (a, b, c, d) { return [P, a, b, Q, a + c, b, a + c, b + d, a, b + d, "Z"] }, triangle: function (a, b, c, d) { return [P, a + c / 2, b, Q, a + c, b + d, a, b + d, "Z"] }, "triangle-down": function (a, b, c, d) { return [P, a, b, Q, a + c, b, a + c / 2, b + d, "Z"] }, diamond: function (a, b, c, d) { return [P, a + c / 2, b, Q, a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"] }, arc: function (a, b, c, d, e) { var f = e.start, g = e.r || c || d, h = e.end - 1e-6, i = e.innerR, j = k(f), n = l(f), o = k(h), p = l(h), q = e.end - f < m ? 0 : 1; return [P, a + g * j, b + g * n, "A", g, g, 0, q, 1, a + g * o, b + g * p, Q, a + i * o, b + i * p, "A", i, i, 0, q, 0, a + i * j, b + i * n, "Z"] } }, clipRect: function (a, b, c, d) { var e, f = L + A++, g = this.createElement("clipPath").attr({ id: f }).add(this.defs); e = this.rect(a, b, c, d, 0).add(g); e.id = f; e.clipPath = g; return e }, color: function (a, b, c) { var d, e = /^rgba/; if (a && a.linearGradient) { var f = this, g = a[cb], h = !Lb(g), i, j = f.gradients, k, l = g.x1 || g[0] || 0, m = g.y1 || g[1] || 0, n = g.x2 || g[2] || 0, o = g.y2 || g[3] || 0, p, q, r = [h, l, m, n, o, a.stops.join(",")].join(","); if (j[r]) { i = Rb(j[r].element, "id") } else { i = L + A++; k = f.createElement(cb).attr(Gb({ id: i, x1: l, y1: m, x2: n, y2: o }, h ? null : { gradientUnits: "userSpaceOnUse" })).add(f.defs); k.stops = []; vb(a.stops, function (a) { var b; if (e.test(a[1])) { d = zc(a[1]); p = d.get("rgb"); q = d.get("a") } else { p = a[1]; q = 1 } b = f.createElement("stop").attr({ offset: a[0], "stop-color": p, "stop-opacity": q }).add(k); k.stops.push(b) }); j[r] = k } return "url(" + this.url + "#" + i + ")" } else if (e.test(a)) { d = zc(a); Rb(b, c + "-opacity", d.get("a")); return d.get("rgb") } else { b.removeAttribute(c + "-opacity"); return a } }, text: function (a, b, c, d) { var f = this, g = C.chart.style, h; if (d && !f.forExport) { return f.html(a, b, c) } b = e(Tb(b, 0)); c = e(Tb(c, 0)); h = f.createElement("text").attr({ x: b, y: c, text: a }).css({ fontFamily: g.fontFamily, fontSize: g.fontSize }); h.x = b; h.y = c; return h }, html: function (a, b, c) { var d = C.chart.style, f = this.createElement("span"), g = f.attrSetters, h = f.element, i = f.renderer; g.text = function (a) { h.innerHTML = a; return false }; g.x = g.y = g.align = function (a, b) { if (b === "align") { b = "textAlign" } f[b] = a; f.htmlUpdateTransform(); return false }; f.attr({ text: a, x: e(b), y: e(c) }).css({ position: I, whiteSpace: "nowrap", fontFamily: d.fontFamily, fontSize: d.fontSize }); f.css = f.htmlCss; if (i.isSVG) { f.add = function (a) { var b, c, d = i.box.parentNode; if (a) { b = a.div; if (!b) { b = a.div = Vb(H, { className: Rb(a.element, "class") }, { position: I, left: a.attr("translateX") + N, top: a.attr("translateY") + N }, d); c = b.style; Gb(a.attrSetters, { translateX: function (a) { c.left = a + N }, translateY: function (a) { c.top = a + N }, visibility: function (a, b) { c[b] = a } }) } } else { b = d } b.appendChild(h); f.added = true; if (f.alignOnAdd) { f.htmlUpdateTransform() } return f } } return f }, fontMetrics: function (a) { a = Ib(a || 11); var b = a < 24 ? a + 4 : e(a * 1.2), c = e(b * .8); return { h: b, b: c} }, label: function (b, c, d, f, g, h, i, j) { function z() { var a, b = m.element.style; o = (r === undefined || s === undefined || l.styles.textAlign) && m.getBBox(true); l.width = (r || o.width) + 2 * q; l.height = (s || o.height) + 2 * q; x = q + k.fontMetrics(b && b.fontSize).b; if (!n) { a = j ? -x : 0; l.box = n = f ? k.symbol(f, 0, a, l.width, l.height) : k.rect(0, a, l.width, l.height, 0, w[fb]); n.add(l) } n.attr(zb({ width: l.width, height: l.height }, w)); w = null } function A() { var a = l.styles, b = a && a.textAlign, c = q, d; d = j ? 0 : x; if (Qb(r) && (b === "center" || b === "right")) { c += { center: .5, right: 1}[b] * (r - o.width) } if (c !== m.x || d !== m.y) { m.attr({ x: c, y: d }) } m.x = c; m.y = d } function B(a, b) { if (n) { n.attr(a, b) } else { w[a] = b } } function C() { l.attr({ text: b, x: c, y: d, anchorX: g, anchorY: h }) } var k = this, l = k.g(), m = k.text("", 0, 0, i).attr({ zIndex: 1 }).add(l), n, o, p = "left", q = 3, r, s, t, u, v = 0, w = {}, x, y = l.attrSetters; Ab(l, "add", C); y.width = function (a) { r = a; return false }; y.height = function (a) { s = a; return false }; y.padding = function (a) { if (Qb(a) && a !== q) { q = a; A() } return false }; y.align = function (a) { p = a; return false }; y.text = function (a, b) { m.attr(b, a); z(); A(); return false }; y[fb] = function (a, b) { v = a % 2 / 2; B(b, a); return false }; y.stroke = y.fill = y.r = function (a, b) { B(b, a); return false }; y.anchorX = function (a, b) { g = a; B(b, a + v - t); return false }; y.anchorY = function (a, b) { h = a; B(b, a - u); return false }; y.x = function (a) { a -= { left: 0, center: .5, right: 1}[p] * ((r || o.width) + q); t = l.x = e(a); l.attr("translateX", t); return false }; y.y = function (a) { u = l.y = e(a); l.attr("translateY", a); return false }; var D = l.css; return Gb(l, { css: function (b) { if (b) { var c = {}; b = zb({}, b); vb(["fontSize", "fontWeight", "fontFamily", "color", "lineHeight", "width"], function (d) { if (b[d] !== a) { c[d] = b[d]; delete b[d] } }); m.css(c) } return D.call(l, b) }, getBBox: function () { return n.getBBox() }, shadow: function (a) { n.shadow(a); return l }, destroy: function () { Bb(l, "add", C); Bb(l.element, "mouseenter"); Bb(l.element, "mouseleave"); if (m) { m = m.destroy() } Ac.prototype.destroy.call(l) } }) } }; x = Bc; var Cc; if (!u && !w) { var Dc = { init: function (a, b) { var c = this, d = ["<", b, ' filled="f" stroked="f"'], e = ["position: ", I, ";"]; if (b === "shape" || b === H) { e.push("left:0;top:0;width:10px;height:10px;") } if (q) { e.push("visibility: ", b === H ? K : M) } d.push(' style="', e.join(""), '"/>'); if (b) { d = b === H || b === "span" || b === "img" ? d.join("") : a.prepVML(d); c.element = Vb(d) } c.renderer = a; c.attrSetters = {} }, add: function (a) { var b = this, c = b.renderer, d = b.element, e = c.box, f = a && a.inverted, g = a ? a.element || a : e; if (f) { c.invertChild(d, g) } if (q && g.gVis === K) { Ub(d, { visibility: K }) } g.appendChild(d); b.added = true; if (b.alignOnAdd && !b.deferUpdateTransform) { b.updateTransform() } Cb(b, "add"); return b }, toggleChildren: function (a, b) { var c = a.childNodes, d = c.length; while (d--) { Ub(c[d], { visibility: b }); if (c[d].nodeName === "DIV") { this.toggleChildren(c[d], b) } } }, updateTransform: Ac.prototype.htmlUpdateTransform, attr: function (b, c) { var d = this, f, g, i, j, k = d.element || {}, l = k.style, m = k.nodeName, n = d.renderer, o = d.symbolName, p, r = d.shadows, s, t = d.attrSetters, u = d; if (Jb(b) && Qb(c)) { f = b; b = {}; b[f] = c } if (Jb(b)) { f = b; if (f === "strokeWidth" || f === "stroke-width") { u = d.strokeweight } else { u = d[f] } } else { for (f in b) { g = b[f]; s = false; j = t[f] && t[f](g, f); if (j !== false && g !== null) { if (j !== a) { g = j } if (o && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(f)) { if (!p) { d.symbolAttr(b); p = true } s = true } else if (f === "d") { g = g || []; d.d = g.join(" "); i = g.length; var v = []; while (i--) { if (Mb(g[i])) { v[i] = e(g[i] * 10) - 5 } else if (g[i] === "Z") { v[i] = "x" } else { v[i] = g[i] } } g = v.join(" ") || "x"; k.path = g; if (r) { i = r.length; while (i--) { r[i].path = g } } s = true } else if (f === "zIndex" || f === "visibility") { if (q && f === "visibility" && m === "DIV") { k.gVis = g; d.toggleChildren(k, g); if (g === M) { g = null } } if (g) { l[f] = g } s = true } else if (f === "width" || f === "height") { g = h(0, g); this[f] = g; if (d.updateClipping) { d[f] = g; d.updateClipping() } else { l[f] = g } s = true } else if (f === "x" || f === "y") { d[f] = g; l[{ x: "left", y: "top"}[f]] = g } else if (f === "class") { k.className = g } else if (f === "stroke") { g = n.color(g, k, f); f = "strokecolor" } else if (f === "stroke-width" || f === "strokeWidth") { k.stroked = g ? true : false; f = "strokeweight"; d[f] = g; if (Mb(g)) { g += N } } else if (f === "dashstyle") { var w = k.getElementsByTagName("stroke")[0] || Vb(n.prepVML(["<stroke/>"]), null, null, k); w[f] = g || "solid"; d.dashstyle = g; s = true } else if (f === "fill") { if (m === "SPAN") { l.color = g } else { k.filled = g !== O ? true : false; g = n.color(g, k, f); f = "fillcolor" } } else if (f === "translateX" || f === "translateY" || f === "rotation") { d[f] = g; d.updateTransform(); s = true } else if (f === "text") { this.bBox = null; k.innerHTML = g; s = true } if (r && f === "visibility") { i = r.length; while (i--) { r[i].style[f] = g } } if (!s) { if (q) { k[f] = g } else { Rb(k, f, g) } } } } } return u }, clip: function (a) { var b = this, c = a.members; c.push(b); b.destroyClip = function () { Pb(c, b) }; return b.css(a.getCSS(b.inverted)) }, css: Ac.prototype.htmlCss, safeRemoveChild: function (a) { var b = a.parentNode; if (b) { gc(a) } }, destroy: function () { var a = this; if (a.destroyClip) { a.destroyClip() } return Ac.prototype.destroy.apply(a) }, empty: function () { var a = this.element, b = a.childNodes, c = b.length, d; while (c--) { d = b[c]; d.parentNode.removeChild(d) } }, on: function (a, b) { this.element["on" + a] = function () { var a = c.event; a.target = a.srcElement; b(a) }; return this }, shadow: function (a, b) { var c = [], d, e = this.element, f = this.renderer, g, h = e.style, i, j = e.path; if (j && typeof j.value !== "string") { j = "x" } if (a) { for (d = 1; d <= 3; d++) { i = ['<shape isShadow="true" strokeweight="', 7 - 2 * d, '" filled="false" path="', j, '" coordsize="100,100" style="', e.style.cssText, '" />']; g = Vb(f.prepVML(i), null, { left: Ib(h.left) + 1, top: Ib(h.top) + 1 }); i = ['<stroke color="black" opacity="', .05 * d, '"/>']; Vb(f.prepVML(i), null, null, g); if (b) { b.element.appendChild(g) } else { e.parentNode.insertBefore(g, e) } c.push(g) } this.shadows = c } return this } }; Dc = Wb(Ac, Dc); var Ec = { Element: Dc, isIE8: o.indexOf("MSIE 8.0") > -1, init: function (a, c, d) { var e = this, f, g; e.alignedObjects = []; f = e.createElement(H); g = f.element; g.style.position = J; a.appendChild(f.element); e.box = g; e.boxWrapper = f; e.setSize(c, d, false); if (!b.namespaces.hcv) { b.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"); b.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke" + "{ behavior:url(#default#VML); display: inline-block; } " } }, clipRect: function (a, b, c, d) { var f = this.createElement(); return Gb(f, { members: [], left: a, top: b, width: c, height: d, getCSS: function (a) { var b = this, c = b.top, d = b.left, f = d + b.width, g = c + b.height, h = { clip: "rect(" + e(a ? d : c) + "px," + e(a ? g : f) + "px," + e(a ? f : g) + "px," + e(a ? c : d) + "px)" }; if (!a && q) { Gb(h, { width: f + N, height: g + N }) } return h }, updateClipping: function () { vb(f.members, function (a) { a.css(f.getCSS(a.inverted)) }) } }) }, color: function (a, b, c) { var e, f = /^rgba/, g; if (a && a[cb]) { var h, i, j = a[cb], k = j.x1 || j[0] || 0, l = j.y1 || j[1] || 0, n = j.x2 || j[2] || 0, o = j.y2 || j[3] || 0, p, q, r, s, t; vb(a.stops, function (a, b) { if (f.test(a[1])) { e = zc(a[1]); h = e.get("rgb"); i = e.get("a") } else { h = a[1]; i = 1 } if (!b) { q = h; r = i } else { s = h; t = i } }); if (c === "fill") { p = 90 - d.atan((o - l) / (n - k)) * 180 / m; g = ['<fill colors="0% ', q, ",100% ", s, '" angle="', p, '" opacity="', t, '" o:opacity2="', r, '" type="gradient" focus="100%" method="sigma" />']; Vb(this.prepVML(g), null, null, b) } else { return h } } else if (f.test(a) && b.tagName !== "IMG") { e = zc(a); g = ["<", c, ' opacity="', e.get("a"), '"/>']; Vb(this.prepVML(g), null, null, b); return e.get("rgb") } else { var u = b.getElementsByTagName(c); if (u.length) { u[0].opacity = 1 } return a } }, prepVML: function (a) { var b = "display:inline-block;behavior:url(#default#VML);", c = this.isIE8; a = a.join(""); if (c) { a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'); if (a.indexOf('style="') === -1) { a = a.replace("/>", ' style="' + b + '" />') } else { a = a.replace('style="', 'style="' + b) } } else { a = a.replace("<", "<hcv:") } return a }, text: Bc.prototype.html, path: function (a) { return this.createElement("shape").attr({ coordsize: "100 100", d: a }) }, circle: function (a, b, c) { return this.symbol("circle").attr({ x: a - c, y: b - c, width: 2 * c, height: 2 * c }) }, g: function (a) { var b, c; if (a) { c = { className: L + a, "class": L + a} } b = this.createElement(H).attr(c); return b }, image: function (a, b, c, d, e) { var f = this.createElement("img").attr({ src: a }); if (arguments.length > 1) { f.css({ left: b, top: c, width: d, height: e }) } return f }, rect: function (a, b, c, d, e, f) { if (Kb(a)) { b = a.y; c = a.width; d = a.height; f = a.strokeWidth; a = a.x } var g = this.symbol("rect"); g.r = e; return g.attr(g.crisp(f, a, b, h(c, 0), h(d, 0))) }, invertChild: function (a, b) { var c = b.style; Ub(a, { flip: "x", left: Ib(c.width) - 10, top: Ib(c.height) - 10, rotation: -90 }) }, symbols: { arc: function (a, b, c, d, e) { var f = e.start, g = e.end, h = e.r || c || d, i = k(f), j = l(f), n = k(g), o = l(g), p = e.innerR, q = .08 / h, r = p && .25 / p || 0; if (g - f === 0) { return ["x"] } else if (2 * m - g + f < q) { n = -q } else if (g - f < r) { n = k(f + r) } return ["wa", a - h, b - h, a + h, b + h, a + h * i, b + h * j, a + h * n, b + h * o, "at", a - p, b - p, a + p, b + p, a + p * n, b + p * o, a + p * i, b + p * j, "x", "e"] }, circle: function (a, b, c, d) { return ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"] }, rect: function (a, b, c, d, e) { if (!Qb(e)) { return [] } var f = a + c, g = b + d, h = i(e.r || 0, c, d); return [P, a + h, b, Q, f - h, b, "wa", f - 2 * h, b, f, b + 2 * h, f - h, b, f, b + h, Q, f, g - h, "wa", f - 2 * h, g - 2 * h, f, g, f, g - h, f - h, g, Q, a + h, g, "wa", a, g - 2 * h, a + 2 * h, g, a + h, g, a, g - h, Q, a, b + h, "wa", a, b, a + 2 * h, b + 2 * h, a, b + h, a + h, b, "x", "e"] } } }; Cc = function () { this.init.apply(this, arguments) }; Cc.prototype = zb(Bc.prototype, Ec); x = Cc } var Fc, Gc; if (w) { Fc = function () { }; Gc = function () { function b() { var b = a.length, c; for (c = 0; c < b; c++) { a[c]() } a = [] } var a = []; return { push: function (c, d) { if (a.length === 0) { ub(d, b) } a.push(c) } } } () } x = Cc || Fc || Bc; Hc.prototype.callbacks = []; var Ic = function () { }; Ic.prototype = { init: function (a, b, c) { var d = this, e = a.chart.counters, f; d.series = a; d.applyOptions(b, c); d.pointAttr = {}; if (a.options.colorByPoint) { f = a.chart.options.colors; if (!d.options) { d.options = {} } d.color = d.options.color = d.color || f[e.color++]; e.wrapColor(f.length) } a.chart.pointCount++; return d }, applyOptions: function (b, c) { var d = this, e = d.series, f = typeof b; d.config = b; if (f === "number" || b === null) { d.y = b } else if (typeof b[0] === "number") { d.x = b[0]; d.y = b[1] } else if (f === "object" && typeof b.length !== "number") { Gb(d, b); d.options = b; if (b.dataLabels) { e._hasPointLabels = true } } else if (typeof b[0] === "string") { d.name = b[0]; d.y = b[1] } if (d.x === a) { d.x = c === a ? e.autoIncrement() : c } }, destroy: function () { var a = this, b = a.series, c = b.chart.hoverPoints, d; b.chart.pointCount--; if (c) { a.setState(); Pb(c, a) } if (a === b.chart.hoverPoint) { a.onMouseOut() } b.chart.hoverPoints = null; if (a.graphic || a.dataLabel) { Bb(a); a.destroyElements() } if (a.legendItem) { a.series.chart.legend.destroyItem(a) } for (d in a) { a[d] = null } }, destroyElements: function () { var a = this, b = ["graphic", "tracker", "dataLabel", "group", "connector", "shadowGroup"], c, d = 6; while (d--) { c = b[d]; if (a[c]) { a[c] = a[c].destroy() } } }, getLabelConfig: function () { var a = this; return { x: a.category, y: a.y, key: a.name || a.category, series: a.series, point: a, percentage: a.percentage, total: a.total || a.stackTotal} }, select: function (a, b) { var c = this, d = c.series, e = d.chart; a = Tb(a, !c.selected); c.firePointEvent(a ? "select" : "unselect", { accumulate: b }, function () { c.selected = a; c.setState(a && U); if (!b) { vb(e.getSelectedPoints(), function (a) { if (a.selected && a !== c) { a.selected = false; a.setState(S); a.firePointEvent("unselect") } }) } }) }, onMouseOver: function () { var a = this, b = a.series, c = b.chart, d = c.tooltip, e = c.hoverPoint; if (e && e !== a) { e.onMouseOut() } a.firePointEvent("mouseOver"); if (d && (!d.shared || b.noSharedTooltip)) { d.refresh(a) } a.setState(T); c.hoverPoint = a }, onMouseOut: function () { var a = this; a.firePointEvent("mouseOut"); a.setState(); a.series.chart.hoverPoint = null }, tooltipFormatter: function (a) { var b = this, c = b.series, d = c.tooltipOptions, e = String(b.y).split("."), f = e[1] ? e[1].length : 0, g = a.match(/\{(series|point)\.[a-zA-Z]+\}/g), h = /[{\.}]/, i, j, k, l, m, n; for (n in g) { j = g[n]; if (Jb(j) && j !== a) { l = (" " + j).split(h); i = { point: b, series: c}[l[1]]; m = l[2]; if (i === b && (m === "y" || m === "open" || m === "high" || m === "low" || m === "close")) { k = (d.valuePrefix || d.yPrefix || "") + Xb(b[m], Tb(d.valueDecimals, d.yDecimals, f)) + (d.valueSuffix || d.ySuffix || "") } else { k = i[m] } a = a.replace(j, k) } } return a }, update: function (a, b, c) { var d = this, e = d.series, f = d.graphic, g, h = e.data, i = h.length, j = e.chart; b = Tb(b, true); d.firePointEvent("update", { options: a }, function () { d.applyOptions(a); if (Kb(a)) { e.getAttribs(); if (f) { f.attr(d.pointAttr[e.state]) } } for (g = 0; g < i; g++) { if (h[g] === d) { e.xData[g] = d.x; e.yData[g] = d.y; e.options.data[g] = a; break } } e.isDirty = true; e.isDirtyData = true; if (b) { j.redraw(c) } }) }, remove: function (a, b) { var c = this, d = c.series, e = d.chart, f, g = d.data, h = g.length; jc(b, e); a = Tb(a, true); c.firePointEvent("remove", null, function () { for (f = 0; f < h; f++) { if (g[f] === c) { g.splice(f, 1); d.options.data.splice(f, 1); d.xData.splice(f, 1); d.yData.splice(f, 1); break } } c.destroy(); d.isDirty = true; d.isDirtyData = true; if (a) { e.redraw() } }) }, firePointEvent: function (a, b, c) { var d = this, e = this.series, f = e.options; if (f.point.events[a] || d.options && d.options.events && d.options.events[a]) { this.importEvents() } if (a === "click" && f.allowPointSelect) { c = function (a) { d.select(null, a.ctrlKey || a.metaKey || a.shiftKey) } } Cb(this, a, b, c) }, importEvents: function () { if (!this.hasImportedEvents) { var a = this, b = zb(a.series.options.point, a.options), c = b.events, d; a.events = c; for (d in c) { Ab(a, d, c[d]) } this.hasImportedEvents = true } }, setState: function (a) { var b = this, c = b.plotX, d = b.plotY, e = b.series, f = e.options.states, g = uc[e.type].marker && e.options.marker, h = g && !g.enabled, i = g && g.states[a], j = i && i.enabled === false, k = e.stateMarkerGraphic, l = e.chart, m, n = b.pointAttr; a = a || S; if (a === b.state || b.selected && a !== U || f[a] && f[a].enabled === false || a && (j || h && !i.enabled)) { return } if (b.graphic) { m = g && b.graphic.symbolName && n[a].r; b.graphic.attr(zb(n[a], m ? { x: c - m, y: d - m, width: 2 * m, height: 2 * m} : {})) } else { if (a) { if (!k) { m = g.radius; e.stateMarkerGraphic = k = l.renderer.symbol(e.symbol, -m, -m, 2 * m, 2 * m).attr(n[a]).add(e.group) } k.translate(c, d) } if (k) { k[a ? "show" : "hide"]() } } b.state = a } }; var Jc = function () { }; Jc.prototype = { isCartesian: true, type: "line", pointClass: Ic, sorted: true, pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius" }, init: function (a, b) { var c = this, d, e, f = a.series.length; c.chart = a; c.options = b = c.setOptions(b); c.bindAxes(); Gb(c, { index: f, name: b.name || "Series " + (f + 1), state: S, pointAttr: {}, visible: b.visible !== false, selected: b.selected === true }); if (w) { b.animation = false } e = b.events; for (d in e) { Ab(c, d, e[d]) } if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) { a.runTrackerClick = true } c.getColor(); c.getSymbol(); c.setData(b.data, false) }, bindAxes: function () { var b = this, c = b.options, d = b.chart, e; if (b.isCartesian) { vb(["xAxis", "yAxis"], function (f) { vb(d[f], function (d) { e = d.options; if (c[f] === e.index || c[f] === a && e.index === 0) { d.series.push(b); b[f] = d; d.isDirty = true } }) }) } }, autoIncrement: function () { var a = this, b = a.options, c = a.xIncrement; c = Tb(c, b.pointStart, 0); a.pointInterval = Tb(a.pointInterval, b.pointInterval, 1); a.xIncrement = c + a.pointInterval; return c }, getSegments: function () { var a = this, b = -1, c = [], d, e = a.points, f = e.length; if (f) { if (a.options.connectNulls) { d = f; while (d--) { if (e[d].y === null) { e.splice(d, 1) } } if (e.length) { c = [e] } } else { vb(e, function (a, d) { if (a.y === null) { if (d > b + 1) { c.push(e.slice(b + 1, d)) } b = d } else if (d === f - 1) { c.push(e.slice(b + 1, d + 1)) } }) } } a.segments = c }, setOptions: function (a) { var b = this, c = b.chart, d = c.options, e = d.plotOptions, f = a.data, g; a.data = null; g = zb(e[this.type], e.series, a); g.data = a.data = f; b.tooltipOptions = zb(d.tooltip, g.tooltip); return g }, getColor: function () { var a = this.chart.options.colors, b = this.chart.counters; this.color = this.options.color || a[b.color++] || "#0000ff"; b.wrapColor(a.length) }, getSymbol: function () { var a = this, b = a.options.marker, c = a.chart, d = c.options.symbols, e = c.counters; a.symbol = b.symbol || d[e.symbol++]; if (/^url/.test(a.symbol)) { b.radius = 0 } e.wrapSymbol(d.length) }, addPoint: function (a, b, c, d) { var e = this, f = e.data, g = e.graph, h = e.area, i = e.chart, j = e.xData, k = e.yData, l = g && g.shift || 0, m = e.options.data, n; jc(d, i); if (g && c) { g.shift = l + 1 } if (h) { if (c) { h.shift = l + 1 } h.isArea = true } b = Tb(b, true); n = { series: e }; e.pointClass.prototype.applyOptions.apply(n, [a]); j.push(n.x); k.push(e.valueCount === 4 ? [n.open, n.high, n.low, n.close] : n.y); m.push(a); if (c) { if (f[0] && f[0].remove) { f[0].remove(false) } else { f.shift(); j.shift(); k.shift(); m.shift() } } e.getAttribs(); e.isDirty = true; e.isDirtyData = true; if (b) { i.redraw() } }, setData: function (a, b) { var c = this, d = c.points, e = c.options, f = c.initialColor, g = c.chart, h = null, i; c.xIncrement = null; c.pointRange = c.xAxis && c.xAxis.categories && 1 || e.pointRange; if (Qb(f)) { g.counters.color = f } var j = [], k = [], l = a ? a.length : [], m = e.turboThreshold || 1e3, n, o = c.valueCount === 4; if (l > m) { i = 0; while (h === null && i < l) { h = a[i]; i++ } if (Mb(h)) { var p = Tb(e.pointStart, 0), q = Tb(e.pointInterval, 1); for (i = 0; i < l; i++) { j[i] = p; k[i] = a[i]; p += q } c.xIncrement = p } else if (Lb(h)) { if (o) { for (i = 0; i < l; i++) { n = a[i]; j[i] = n[0]; k[i] = n.slice(1, 5) } } else { for (i = 0; i < l; i++) { n = a[i]; j[i] = n[0]; k[i] = n[1] } } } } else { for (i = 0; i < l; i++) { n = { series: c }; c.pointClass.prototype.applyOptions.apply(n, [a[i]]); j[i] = n.x; k[i] = o ? [n.open, n.high, n.low, n.close] : n.y } } c.data = []; c.options.data = a; c.xData = j; c.yData = k; i = d && d.length || 0; while (i--) { if (d[i] && d[i].destroy) { d[i].destroy() } } c.isDirty = c.isDirtyData = g.isDirtyBox = true; if (Tb(b, true)) { g.redraw(false) } }, remove: function (a, b) { var c = this, d = c.chart; a = Tb(a, true); if (!c.isRemoving) { c.isRemoving = true; Cb(c, "remove", null, function () { c.destroy(); d.isDirtyLegend = d.isDirtyBox = true; if (a) { d.redraw(b) } }) } c.isRemoving = false }, processData: function (b) { var c = this, d = c.xData, e = c.yData, f = d.length, g = 0, i = f, j, k, l, m = c.xAxis, n, o = c.options, p = o.cropThreshold, q = c.isCartesian; if (q && !c.isDirty && !m.isDirty && !c.yAxis.isDirty && !b) { return false } if (q && c.sorted && (!p || f > p || c.forceCrop)) { var r = m.getExtremes(), s = r.min, t = r.max; if (d[f - 1] < s || d[0] > t) { d = []; e = [] } else if (d[0] < s || d[f - 1] > t) { for (n = 0; n < f; n++) { if (d[n] >= s) { g = h(0, n - 1); break } } for (; n < f; n++) { if (d[n] > t) { i = n + 1; break } } d = d.slice(g, i); e = e.slice(g, i); j = true } } for (n = d.length - 1; n > 0; n--) { k = d[n] - d[n - 1]; if (k > 0 && (l === a || k < l)) { l = k } } c.cropped = j; c.cropStart = g; c.processedXData = d; c.processedYData = e; if (o.pointRange === null) { c.pointRange = l || 1 } c.closestPointRange = l }, generatePoints: function () { var a = this, b = a.options, c = b.data, d = a.data, e, f = a.processedXData, g = a.processedYData, h = a.pointClass, i = f.length, j = a.cropStart || 0, k, l = a.hasGroupedData, m, n = [], o; if (!d && !l) { var p = []; p.length = c.length; d = a.data = p } for (o = 0; o < i; o++) { k = j + o; if (!l) { if (d[k]) { m = d[k] } else { d[k] = m = (new h).init(a, c[k], f[o]) } n[o] = m } else { n[o] = (new h).init(a, [f[o]].concat(Sb(g[o]))) } } if (d && (i !== (e = d.length) || l)) { for (o = 0; o < e; o++) { if (o === j && !l) { o += i } if (d[o]) { d[o].destroyElements() } } } a.data = d; a.points = n }, translate: function () { if (!this.processedXData) { this.processData() } this.generatePoints(); var b = this, c = b.chart, d = b.options, f = d.stacking, g = b.xAxis, h = g.categories, i = b.yAxis, j = b.points, k = j.length, l = !!b.modifyValue, m, n = i.series, o = n.length; while (o--) { if (n[o].visible) { if (o === b.index) { m = true } break } } for (o = 0; o < k; o++) { var p = j[o], q = p.x, r = p.y, s = p.low, t = i.stacks[(r < d.threshold ? "-" : "") + b.stackKey], u, v; p.plotX = e(g.translate(q, 0, 0, 0, 1) * 10) / 10; if (f && b.visible && t && t[q]) { u = t[q]; v = u.total; u.cum = s = u.cum - r; r = s + r; if (m) { s = d.threshold } if (f === "percent") { s = v ? s * 100 / v : 0; r = v ? r * 100 / v : 0 } p.percentage = v ? p.y * 100 / v : 0; p.stackTotal = v; p.stackY = r } p.yBottom = Qb(s) ? i.translate(s, 0, 1, 0, 1) : null; if (l) { r = b.modifyValue(r, p) } p.plotY = typeof r === "number" ? e(i.translate(r, 0, 1, 0, 1) * 10) / 10 : a; p.clientX = c.inverted ? c.plotHeight - p.plotX : p.plotX; p.category = h && h[p.x] !== a ? h[p.x] : p.x } b.getSegments() }, setTooltipPoints: function (a) { var b = this, c = b.chart, d = c.inverted, g = [], h, i = e((d ? c.plotTop : c.plotLeft) + c.plotSizeX), j, k, l = b.xAxis, m, n, o = []; if (b.options.enableMouseTracking === false) { return } if (a) { b.tooltipPoints = null } vb(b.segments || b.points, function (a) { g = g.concat(a) }); if (l && l.reversed) { g = g.reverse() } h = g.length; for (n = 0; n < h; n++) { m = g[n]; j = g[n - 1] ? g[n - 1]._high + 1 : 0; k = m._high = g[n + 1] ? f((m.plotX + (g[n + 1] ? g[n + 1].plotX : i)) / 2) : i; while (j <= k) { o[d ? i - j++ : j++] = m } } b.tooltipPoints = o }, tooltipHeaderFormatter: function (a) { var b = this, c = b.tooltipOptions, d = c.xDateFormat || "%A, %b %e, %Y", e = b.xAxis, f = e && e.options.type === "datetime"; return c.headerFormat.replace("{point.key}", f ? D(d, a) : a).replace("{series.name}", b.name).replace("{series.color}", b.color) }, onMouseOver: function () { var a = this, b = a.chart, c = b.hoverSeries; if (!y && b.mouseIsDown) { return } if (c && c !== a) { c.onMouseOut() } if (a.options.events.mouseOver) { Cb(a, "mouseOver") } a.setState(T); b.hoverSeries = a }, onMouseOut: function () { var a = this, b = a.options, c = a.chart, d = c.tooltip, e = c.hoverPoint; if (e) { e.onMouseOut() } if (a && b.events.mouseOut) { Cb(a, "mouseOut") } if (d && !b.stickyTracking && !d.shared) { d.hide() } a.setState(); c.hoverSeries = null }, animate: function (a) { var b = this, c = b.chart, d = b.clipRect, e = b.options.animation; if (e && !Kb(e)) { e = {} } if (a) { if (!d.isAnimating) { d.attr("width", 0); d.isAnimating = true } } else { d.animate({ width: c.plotSizeX }, e); this.animate = null } }, drawPoints: function () { var b = this, c, d = b.points, e = b.chart, f, g, h, i, j, k, l, m; if (b.options.marker.enabled) { h = d.length; while (h--) { i = d[h]; f = i.plotX; g = i.plotY; m = i.graphic; if (g !== a && !isNaN(g)) { c = i.pointAttr[i.selected ? U : S]; j = c.r; k = Tb(i.marker && i.marker.symbol, b.symbol); l = k.indexOf("url") === 0; if (m) { m.animate(Gb({ x: f - j, y: g - j }, m.symbolName ? { width: 2 * j, height: 2 * j} : {})) } else if (j > 0 || l) { i.graphic = e.renderer.symbol(k, f - j, g - j, 2 * j, 2 * j).attr(c).add(b.group) } } } } }, convertAttribs: function (a, b, c, d) { var e = this.pointAttrToOptions, f, g, h = {}; a = a || {}; b = b || {}; c = c || {}; d = d || {}; for (f in e) { g = e[f]; h[f] = Tb(a[g], b[f], c[f], d[f]) } return h }, getAttribs: function () { var a = this, b = uc[a.type].marker ? a.options.marker : a.options, c = b.states, d = c[T], e, f = a.color, g = { stroke: f, fill: f }, h = a.points, i, j, k = [], l, m = a.pointAttrToOptions, n, o; if (a.options.marker) { d.radius = d.radius || b.radius + 2; d.lineWidth = d.lineWidth || b.lineWidth + 1 } else { d.color = d.color || zc(d.color || f).brighten(d.brightness).get() } k[S] = a.convertAttribs(b, g); vb([T, U], function (b) { k[b] = a.convertAttribs(c[b], k[S]) }); a.pointAttr = k; i = h.length; while (i--) { j = h[i]; b = j.options && j.options.marker || j.options; if (b && b.enabled === false) { b.radius = 0 } n = false; if (j.options) { for (o in m) { if (Qb(b[m[o]])) { n = true } } } if (n) { l = []; c = b.states || {}; e = c[T] = c[T] || {}; if (!a.options.marker) { e.color = zc(e.color || j.options.color).brighten(e.brightness || d.brightness).get() } l[S] = a.convertAttribs(b, k[S]); l[T] = a.convertAttribs(c[T], k[T], l[S]); l[U] = a.convertAttribs(c[U], k[U], l[S]) } else { l = k } j.pointAttr = l } }, destroy: function () { var a = this, b = a.chart, c = a.clipRect, d = /AppleWebKit\/533/.test(o), e, f, g = a.data || [], h, i, j; Cb(a, "destroy"); Bb(a); vb(["xAxis", "yAxis"], function (b) { j = a[b]; if (j) { Pb(j.series, a); j.isDirty = true } }); if (a.legendItem) { a.chart.legend.destroyItem(a) } f = g.length; while (f--) { h = g[f]; if (h && h.destroy) { h.destroy() } } a.points = null; if (c && c !== b.clipRect) { a.clipRect = c.destroy() } vb(["area", "graph", "dataLabelsGroup", "group", "tracker"], function (b) { if (a[b]) { e = d && b === "group" ? "hide" : "destroy"; a[b][e]() } }); if (b.hoverSeries === a) { b.hoverSeries = null } Pb(b.series, a); for (i in a) { delete a[i] } }, drawDataLabels: function () { var a = this, b = a.options, c = b.dataLabels; if (c.enabled || a._hasPointLabels) { var d, f, g = a.points, h, i, j, k = a.dataLabelsGroup, l = a.chart, m = a.xAxis, n = m ? m.left : l.plotLeft, o = a.yAxis, p = o ? o.top : l.plotTop, q = l.renderer, r = l.inverted, s = a.type, t = b.stacking, u = s === "column" || s === "bar", v = c.verticalAlign === null, w = c.y === null, x = q.fontMetrics(c.style.fontSize), y = x.h, z = x.b, A, B; if (u) { var C = { top: z, middle: z - y / 2, bottom: -y + z }; if (t) { if (v) { c = zb(c, { verticalAlign: "middle" }) } if (w) { c = zb(c, { y: C[c.verticalAlign] }) } } else { if (v) { c = zb(c, { verticalAlign: "top" }) } else if (w) { c = zb(c, { y: C[c.verticalAlign] }) } } } if (!k) { k = a.dataLabelsGroup = q.g("data-labels").attr({ visibility: a.visible ? M : K, zIndex: 6 }).translate(n, p).add() } else { k.translate(n, p) } i = c; vb(g, function (g) { A = g.dataLabel; c = i; h = g.options; if (h && h.dataLabels) { c = zb(c, h.dataLabels) } B = c.enabled; if (B) { var m = g.barX && g.barX + g.barW / 2 || Tb(g.plotX, -999), n = Tb(g.plotY, -999), o = c.y === null ? g.y >= b.threshold ? -y + z : z : c.y; d = (r ? l.plotWidth - n : m) + c.x; f = e((r ? l.plotHeight - m : n) + o) } if (A && a.isCartesian && (!l.isInsidePlot(d, f) || !B)) { g.dataLabel = A.destroy() } else if (B) { var p = c.align; j = c.formatter.call(g.getLabelConfig(), c); if (s === "column") { d += { left: -1, right: 1}[p] * g.barW / 2 || 0 } if (!t && r && g.y < 0) { p = "right"; d -= 10 } c.style.color = Tb(c.color, c.style.color, a.color, "black"); if (A) { A.attr({ text: j }).animate({ x: d, y: f }) } else if (Qb(j)) { A = g.dataLabel = q[c.rotation ? "text" : "label"](j, d, f, null, null, null, c.useHTML, true).attr({ align: p, fill: c.backgroundColor, stroke: c.borderColor, "stroke-width": c.borderWidth, r: c.borderRadius, rotation: c.rotation, padding: c.padding, zIndex: 1 }).css(c.style).add(k).shadow(c.shadow) } if (u && b.stacking && A) { var v = g.barX, w = g.barY, x = g.barW, C = g.barH; A.align(c, null, { x: r ? l.plotWidth - w - C : v, y: r ? l.plotHeight - v - x : w, width: r ? C : x, height: r ? x : C }) } } }) } }, drawGraph: function () { var a = this, b = a.options, c = a.chart, d = a.graph, e = [], f, g = a.area, h = a.group, i = b.lineColor || a.color, j = b.lineWidth, k = b.dashStyle, l, m = c.renderer, n = a.yAxis.getThreshold(b.threshold), o = /^area/.test(a.type), p = [], q = [], r; vb(a.segments, function (c) { l = []; vb(c, function (d, e) { if (a.getPointSpline) { l.push.apply(l, a.getPointSpline(c, d, e)) } else { l.push(e ? Q : P); if (e && b.step) { var f = c[e - 1]; l.push(d.plotX, f.plotY) } l.push(d.plotX, d.plotY) } }); if (c.length > 1) { e = e.concat(l) } else { p.push(c[0]) } if (o) { var d = [], f, g = l.length; for (f = 0; f < g; f++) { d.push(l[f]) } if (g === 3) { d.push(Q, l[1], l[2]) } if (b.stacking && a.type !== "areaspline") { for (f = c.length - 1; f >= 0; f--) { if (f < c.length - 1 && b.step) { d.push(c[f + 1].plotX, c[f].yBottom) } d.push(c[f].plotX, c[f].yBottom) } } else { d.push(Q, c[c.length - 1].plotX, n, Q, c[0].plotX, n) } q = q.concat(d) } }); a.graphPath = e; a.singlePoints = p; if (o) { f = Tb(b.fillColor, zc(a.color).setOpacity(b.fillOpacity || .75).get()); if (g) { g.animate({ d: q }) } else { a.area = a.chart.renderer.path(q).attr({ fill: f }).add(h) } } if (d) { Eb(d); d.animate({ d: e }) } else { if (j) { r = { stroke: i, "stroke-width": j }; if (k) { r.dashstyle = k } a.graph = m.path(e).attr(r).add(h).shadow(b.shadow) } } }, invertGroups: function () { function e() { var d = { width: a.yAxis.len, height: a.xAxis.len }; b.attr(d).invert(); if (c) { c.attr(d).invert() } } var a = this, b = a.group, c = a.trackerGroup, d = a.chart; Ab(d, "resize", e); Ab(a, "destroy", function () { Bb(d, "resize", e) }); e(); a.invertGroups = e }, render: function () { var a = this, b = a.chart, c, d = a.options, e = d.clip !== false, f = d.animation, g = f && a.animate, h = g ? f && f.duration || 500 : 0, i = a.clipRect, j = b.renderer; if (!i) { i = a.clipRect = !b.hasRendered && b.clipRect ? b.clipRect : j.clipRect(0, 0, b.plotSizeX, b.plotSizeY + 1); if (!b.clipRect) { b.clipRect = i } } if (!a.group) { c = a.group = j.g("series"); c.attr({ visibility: a.visible ? M : K, zIndex: d.zIndex }).translate(a.xAxis.left, a.yAxis.top).add(b.seriesGroup) } a.drawDataLabels(); if (g) { a.animate(true) } a.getAttribs(); if (a.drawGraph) { a.drawGraph() } a.drawPoints(); if (a.options.enableMouseTracking !== false) { a.drawTracker() } if (b.inverted) { a.invertGroups() } if (e && !a.hasRendered) { c.clip(i); if (a.trackerGroup) { a.trackerGroup.clip(b.clipRect) } } if (g) { a.animate() } setTimeout(function () { i.isAnimating = false; c = a.group; if (c && i !== b.clipRect && i.renderer) { if (e) { c.clip(a.clipRect = b.clipRect) } i.destroy() } }, h); a.isDirty = a.isDirtyData = false; a.hasRendered = true }, redraw: function () { var a = this, b = a.chart, c = a.isDirtyData, d = a.group; if (d) { if (b.inverted) { d.attr({ width: b.plotWidth, height: b.plotHeight }) } d.animate({ translateX: a.xAxis.left, translateY: a.yAxis.top }) } a.translate(); a.setTooltipPoints(true); a.render(); if (c) { Cb(a, "updatedData") } }, setState: function (a) { var b = this, c = b.options, d = b.graph, e = c.states, f = c.lineWidth; a = a || S; if (b.state !== a) { b.state = a; if (e[a] && e[a].enabled === false) { return } if (a) { f = e[a].lineWidth || f + 1 } if (d && !d.dashstyle) { d.attr({ "stroke-width": f }, a ? 0 : 500) } } }, setVisible: function (b, c) { var d = this, e = d.chart, f = d.legendItem, g = d.group, h = d.tracker, i = d.dataLabelsGroup, j, k, l = d.points, m, n = e.options.chart.ignoreHiddenSeries, o = d.visible; d.visible = b = b === a ? !o : b; j = b ? "show" : "hide"; if (g) { g[j]() } if (h) { h[j]() } else if (l) { k = l.length; while (k--) { m = l[k]; if (m.tracker) { m.tracker[j]() } } } if (i) { i[j]() } if (f) { e.legend.colorizeItem(d, b) } d.isDirty = true; if (d.options.stacking) { vb(e.series, function (a) { if (a.options.stacking && a.visible) { a.isDirty = true } }) } if (n) { e.isDirtyBox = true } if (c !== false) { e.redraw() } Cb(d, j) }, show: function () { this.setVisible(true) }, hide: function () { this.setVisible(false) }, select: function (b) { var c = this; c.selected = b = b === a ? !c.selected : b; if (c.checkbox) { c.checkbox.checked = b } Cb(c, b ? "select" : "unselect") }, drawTrackerGroup: function () { var a = this.trackerGroup, b = this.chart; if (this.isCartesian) { if (!a) { this.trackerGroup = a = b.renderer.g().attr({ zIndex: this.options.zIndex || 1 }).add(b.trackerGroup) } a.translate(this.xAxis.left, this.yAxis.top) } return a }, drawTracker: function () { var a = this, b = a.options, c = [].concat(a.graphPath), d = c.length, e = a.chart, f = e.renderer, g = e.options.tooltip.snap, h = a.tracker, i = b.cursor, j = i && { cursor: i }, k = a.singlePoints, l = a.drawTrackerGroup(), m, n; if (d) { n = d + 1; while (n--) { if (c[n] === P) { c.splice(n + 1, 0, c[n + 1] - g, c[n + 2], Q) } if (n && c[n] === P || n === d) { c.splice(n, 0, Q, c[n - 2] + g, c[n - 1]) } } } for (n = 0; n < k.length; n++) { m = k[n]; c.push(P, m.plotX - g, m.plotY, Q, m.plotX + g, m.plotY) } if (h) { h.attr({ d: c }) } else { a.tracker = f.path(c).attr({ isTracker: true, stroke: R, fill: O, "stroke-linejoin": "bevel", "stroke-width": b.lineWidth + 2 * g, visibility: a.visible ? M : K }).on(y ? "touchstart" : "mouseover", function () { if (e.hoverSeries !== a) { a.onMouseOver() } }).on("mouseout", function () { if (!b.stickyTracking) { a.onMouseOut() } }).css(j).add(l) } } }; var Kc = Wb(Jc); Fb.line = Kc; var Lc = Wb(Jc, { type: "area" }); Fb.area = Lc; var Mc = Wb(Jc, { type: "spline", getPointSpline: function (a, b, c) { var d = 1.5, e = d + 1, f = b.plotX, g = b.plotY, j = a[c - 1], k = a[c + 1], l, m, n, o, p; if (c && c < a.length - 1) { var q = j.plotX, r = j.plotY, s = k.plotX, t = k.plotY, u; l = (d * f + q) / e; m = (d * g + r) / e; n = (d * f + s) / e; o = (d * g + t) / e; u = (o - m) * (n - f) / (n - l) + g - o; m += u; o += u; if (m > r && m > g) { m = h(r, g); o = 2 * g - m } else if (m < r && m < g) { m = i(r, g); o = 2 * g - m } if (o > t && o > g) { o = h(t, g); m = 2 * g - o } else if (o < t && o < g) { o = i(t, g); m = 2 * g - o } b.rightContX = n; b.rightContY = o } if (!c) { p = [P, f, g] } else { p = ["C", j.rightContX || j.plotX, j.rightContY || j.plotY, l || f, m || g, f, g]; j.rightContX = j.rightContY = null } return p } }); Fb.spline = Mc; var Nc = Wb(Mc, { type: "areaspline" }); Fb.areaspline = Nc; var Oc = Wb(Jc, { type: "column", tooltipOutsidePlot: true, pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color", r: "borderRadius" }, init: function () { Jc.prototype.init.apply(this, arguments); var a = this, b = a.chart; if (b.hasRendered) { vb(b.series, function (b) { if (b.type === a.type) { b.isDirty = true } }) } }, translate: function () { var b = this, c = b.chart, d = b.options, e = d.stacking, f = d.borderWidth, k = 0, l = b.xAxis, m = l.reversed, n = {}, o, p; Jc.prototype.translate.apply(b); vb(c.series, function (c) { if (c.type === b.type && c.visible && b.options.group === c.options.group) { if (c.options.stacking) { o = c.stackKey; if (n[o] === a) { n[o] = k++ } p = n[o] } else { p = k++ } c.columnIndex = p } }); var q = b.points, r = j(l.translationSlope) * (l.ordinalSlope || l.closestPointRange || 1), s = r * d.groupPadding, t = r - 2 * s, u = t / k, v = d.pointWidth, w = Qb(v) ? (u - v) / 2 : u * d.pointPadding, x = g(h(Tb(v, u - 2 * w), 1 + 2 * f)), y = (m ? k - b.columnIndex : b.columnIndex) || 0, z = w + (s + y * u - r / 2) * (m ? -1 : 1), A = d.threshold, B = b.yAxis.getThreshold(A), C = Tb(d.minPointLength, 5); vb(q, function (a) { var c = a.plotY, k = Tb(a.yBottom, B), l = a.plotX + z, m = g(i(c, k)), n = g(h(c, k) - m), o = b.yAxis.stacks[(a.y < 0 ? "-" : "") + b.stackKey], p; if (e && b.visible && o && o[a.x]) { o[a.x].setOffset(z, x) } if (j(n) < C) { if (C) { n = C; m = j(m - B) > C ? k - C : B - (c <= B ? C : 0) } } Gb(a, { barX: l, barY: m, barW: x, barH: n }); a.shapeType = "rect"; p = { x: l, y: m, width: x, height: n, r: d.borderRadius, strokeWidth: f }; if (f % 2) { p.y -= 1; p.height += 1 } a.shapeArgs = p; a.trackerArgs = j(n) < 3 && zb(a.shapeArgs, { height: 6, y: m - 3 }) }) }, getSymbol: function () { }, drawGraph: function () { }, drawPoints: function () { var b = this, c = b.options, d = b.chart.renderer, e, f; vb(b.points, function (g) { var h = g.plotY; if (h !== a && !isNaN(h) && g.y !== null) { e = g.graphic; f = g.shapeArgs; if (e) { Eb(e); e.animate(d.Element.prototype.crisp.apply({}, [f.strokeWidth, f.x, f.y, f.width, f.height])) } else { g.graphic = e = d[g.shapeType](f).attr(g.pointAttr[g.selected ? U : S]).add(b.group).shadow(c.shadow) } } }) }, drawTracker: function () { var a = this, b = a.chart, c = b.renderer, d, e, f = +(new Date), g = a.options, h = g.cursor, i = h && { cursor: h }, j = a.drawTrackerGroup(), k; vb(a.points, function (h) { e = h.tracker; d = h.trackerArgs || h.shapeArgs; delete d.strokeWidth; if (h.y !== null) { if (e) { e.attr(d) } else { h.tracker = c[h.shapeType](d).attr({ isTracker: f, fill: R, visibility: a.visible ? M : K }).on(y ? "touchstart" : "mouseover", function (c) { k = c.relatedTarget || c.fromElement; if (b.hoverSeries !== a && Rb(k, "isTracker") !== f) { a.onMouseOver() } h.onMouseOver() }).on("mouseout", function (b) { if (!g.stickyTracking) { k = b.relatedTarget || b.toElement; if (Rb(k, "isTracker") !== f) { a.onMouseOut() } } }).css(i).add(h.group || j) } } }) }, animate: function (a) { var b = this, c = b.points, d = b.options; if (!a) { vb(c, function (a) { var c = a.graphic, e = a.shapeArgs, f = b.yAxis, g = d.threshold; if (c) { c.attr({ height: 0, y: Qb(g) ? f.getThreshold(g) : f.translate(f.getExtremes().min, 0, 1, 0, 1) }); c.animate({ height: e.height, y: e.y }, d.animation) } }); b.animate = null } }, remove: function () { var a = this, b = a.chart; if (b.hasRendered) { vb(b.series, function (b) { if (b.type === a.type) { b.isDirty = true } }) } Jc.prototype.remove.apply(a, arguments) } }); Fb.column = Oc; var Pc = Wb(Oc, { type: "bar", init: function () { this.inverted = true; Oc.prototype.init.apply(this, arguments) } }); Fb.bar = Pc; var Qc = Wb(Jc, { type: "scatter", sorted: false, translate: function () { var a = this; Jc.prototype.translate.apply(a); vb(a.points, function (b) { b.shapeType = "circle"; b.shapeArgs = { x: b.plotX, y: b.plotY, r: a.chart.options.tooltip.snap} }) }, drawTracker: function () { var b = this, c = b.options.cursor, d = c && { cursor: c }, e = b.points, f = e.length, g; while (f--) { g = e[f].graphic; if (g) { g.element._i = f } } if (!b._hasTracking) { b.group.attr({ isTracker: true }).on(y ? "touchstart" : "mouseover", function (c) { b.onMouseOver(); if (c.target._i !== a) { e[c.target._i].onMouseOver() } }).on("mouseout", function () { if (!b.options.stickyTracking) { b.onMouseOut() } }).css(d) } else { b._hasTracking = true } } }); Fb.scatter = Qc; var Rc = Wb(Ic, { init: function () { Ic.prototype.init.apply(this, arguments); var a = this, b; Gb(a, { visible: a.visible !== false, name: Tb(a.name, "Slice") }); b = function () { a.slice() }; Ab(a, "select", b); Ab(a, "unselect", b); return a }, setVisible: function (b) { var c = this, d = c.series.chart, e = c.tracker, f = c.dataLabel, g = c.connector, h = c.shadowGroup, i; c.visible = b = b === a ? !c.visible : b; i = b ? "show" : "hide"; c.group[i](); if (e) { e[i]() } if (f) { f[i]() } if (g) { g[i]() } if (h) { h[i]() } if (c.legendItem) { d.legend.colorizeItem(c, b) } }, slice: function (a, b, c) { var d = this, e = d.series, f = e.chart, g = d.slicedTranslation, h; jc(c, f); b = Tb(b, true); a = d.sliced = Qb(a) ? a : !d.sliced; h = { translateX: a ? g[0] : f.plotLeft, translateY: a ? g[1] : f.plotTop }; d.group.animate(h); if (d.shadowGroup) { d.shadowGroup.animate(h) } } }); var Sc = Wb(Jc, { type: "pie", isCartesian: false, pointClass: Rc, pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color" }, getColor: function () { this.initialColor = this.chart.counters.color }, animate: function () { var a = this, b = a.points; vb(b, function (b) { var c = b.graphic, d = b.shapeArgs, e = -m / 2; if (c) { c.attr({ r: 0, start: e, end: e }); c.animate({ r: d.r, start: d.start, end: d.end }, a.options.animation) } }); a.animate = null }, setData: function () { Jc.prototype.setData.apply(this, arguments); this.processData(); this.generatePoints() }, translate: function () { this.generatePoints(); var a = 0, b = this, c = -.25, f = 1e3, g = b.options, h = g.slicedOffset, j = h + g.borderWidth, n = g.center.concat([g.size, g.innerSize || 0]), o = b.chart, p = o.plotWidth, q = o.plotHeight, r, s, t, u = b.points, v = 2 * m, w, x = i(p, q), y, z, A, B = g.dataLabels.distance; n = yb(n, function (a, b) { y = /%$/.test(a); return y ? [p, q, x, x][b] * Ib(a) / 100 : a }); b.getX = function (a, b) { t = d.asin((a - n[1]) / (n[2] / 2 + B)); return n[0] + (b ? -1 : 1) * k(t) * (n[2] / 2 + B) }; b.center = n; vb(u, function (b) { a += b.y }); vb(u, function (b) { w = a ? b.y / a : 0; r = e(c * v * f) / f; c += w; s = e(c * v * f) / f; b.shapeType = "arc"; b.shapeArgs = { x: n[0], y: n[1], r: n[2] / 2, innerR: n[3] / 2, start: r, end: s }; t = (s + r) / 2; b.slicedTranslation = yb([k(t) * h + o.plotLeft, l(t) * h + o.plotTop], e); z = k(t) * n[2] / 2; A = l(t) * n[2] / 2; b.tooltipPos = [n[0] + z * .7, n[1] + A * .7]; b.labelPos = [n[0] + z + k(t) * B, n[1] + A + l(t) * B, n[0] + z + k(t) * j, n[1] + A + l(t) * j, n[0] + z, n[1] + A, B < 0 ? "center" : t < v / 4 ? "left" : "right", t]; b.percentage = w * 100; b.total = a }); this.setTooltipPoints() }, render: function () { var a = this; a.getAttribs(); this.drawPoints(); if (a.options.enableMouseTracking !== false) { a.drawTracker() } this.drawDataLabels(); if (a.options.animation && a.animate) { a.animate() } a.isDirty = false }, drawPoints: function () { var a = this, b = a.chart, c = b.renderer, d, e, f, g = a.options.shadow, h, i; vb(a.points, function (a) { e = a.graphic; i = a.shapeArgs; f = a.group; h = a.shadowGroup; if (g && !h) { h = a.shadowGroup = c.g("shadow").attr({ zIndex: 4 }).add() } if (!f) { f = a.group = c.g("point").attr({ zIndex: 5 }).add() } d = a.sliced ? a.slicedTranslation : [b.plotLeft, b.plotTop]; f.translate(d[0], d[1]); if (h) { h.translate(d[0], d[1]) } if (e) { e.animate(i) } else { a.graphic = c.arc(i).attr(Gb(a.pointAttr[S], { "stroke-linejoin": "round" })).add(a.group).shadow(g, h) } if (a.visible === false) { a.setVisible(false) } }) }, drawDataLabels: function () { var a = this, b = a.data, c, d = a.chart, e = a.options.dataLabels, f = Tb(e.connectorPadding, 10), g = Tb(e.connectorWidth, 1), h, i, k = Tb(e.softConnector, true), l = e.distance, n = a.center, o = n[2] / 2, p = n[1], q = l > 0, r, s, t, u = [[], []], v, w, x, y, z, A = 2, B; if (!e.enabled) { return } Jc.prototype.drawDataLabels.apply(a); vb(b, function (a) { if (a.dataLabel) { u[a.labelPos[7] < m / 2 ? 0 : 1].push(a) } }); u[1].reverse(); z = function (a, b) { return b.y - a.y }; t = u[0][0] && u[0][0].dataLabel && u[0][0].dataLabel.getBBox().height; while (A--) { var C = [], D, E = [], F = u[A], G, H = F.length, I; for (G = p - o - l; G <= p + o + l; G += t) { C.push(G) } D = C.length; if (H > D) { y = [].concat(F); y.sort(z); B = H; while (B--) { y[B].rank = B } B = H; while (B--) { if (F[B].rank >= D) { F.splice(B, 1) } } H = F.length } for (B = 0; B < H; B++) { c = F[B]; s = c.labelPos; var J = 9999, L, N; for (N = 0; N < D; N++) { L = j(C[N] - s[1]); if (L < J) { J = L; I = N } } if (I < B && C[B] !== null) { I = B } else if (D < H - B + I && C[B] !== null) { I = D - H + B; while (C[I] === null) { I++ } } else { while (C[I] === null) { I++ } } E.push({ i: I, y: C[I] }); C[I] = null } E.sort(z); for (B = 0; B < H; B++) { c = F[B]; s = c.labelPos; r = c.dataLabel; var O = E.pop(), R = s[1]; x = c.visible === false ? K : M; I = O.i; w = O.y; if (R > w && C[I + 1] !== null || R < w && C[I - 1] !== null) { w = R } v = a.getX(I === 0 || I === C.length - 1 ? R : w, A); r.attr({ visibility: x, align: s[6] })[r.moved ? "animate" : "attr"]({ x: v + e.x + ({ left: f, right: -f}[s[6]] || 0), y: w + e.y }); r.moved = true; if (q && g) { h = c.connector; i = k ? [P, v + (s[6] === "left" ? 5 : -5), w, "C", v, w, 2 * s[2] - s[4], 2 * s[3] - s[5], s[2], s[3], Q, s[4], s[5]] : [P, v + (s[6] === "left" ? 5 : -5), w, Q, s[2], s[3], Q, s[4], s[5]]; if (h) { h.animate({ d: i }); h.attr("visibility", x) } else { c.connector = h = a.chart.renderer.path(i).attr({ "stroke-width": g, stroke: e.connectorColor || c.color || "#606060", visibility: x, zIndex: 3 }).translate(d.plotLeft, d.plotTop).add() } } } } }, drawTracker: Oc.prototype.drawTracker, getSymbol: function () { } }); Fb.pie = Sc; var Tc = "dataGrouping", Uc = Jc.prototype, Vc = Uc.processData, Wc = Uc.generatePoints, Xc = Uc.destroy, Yc = Uc.tooltipHeaderFormatter, Zc = "number", $c = { approximation: "average", groupPixelWidth: 2, dateTimeLabelFormats: Hb(V, ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"], W, ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"], X, ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], Y, ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], Z, ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], $, ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], _, ["%B %Y", "%B", "-%B %Y"], ab, ["%Y", "%Y", "-%Y"]) }, _c = [[V, [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [W, [1, 2, 5, 10, 15, 30]], [X, [1, 2, 5, 10, 15, 30]], [Y, [1, 2, 3, 4, 6, 8, 12]], [Z, [1]], [$, [1]], [_, [1, 3, 6]], [ab, null]], ad = { sum: function (a) { var b = a.length, c; if (!b && a.hasNulls) { c = null } else if (b) { c = 0; while (b--) { c += a[b] } } return c }, average: function (a) { var b = a.length, c = ad.sum(a); if (typeof c === Zc && b) { c = c / b } return c }, open: function (b) { return b.length ? b[0] : b.hasNulls ? null : a }, high: function (b) { return b.length ? ec(b) : b.hasNulls ? null : a }, low: function (b) { return b.length ? dc(b) : b.hasNulls ? null : a }, close: function (b) { return b.length ? b[b.length - 1] : b.hasNulls ? null : a }, ohlc: function (a, b, c, d) { a = ad.open(a); b = ad.high(b); c = ad.low(c); d = ad.close(d); if (typeof a === Zc || typeof b === Zc || typeof c === Zc || typeof d === Zc) { return [a, b, c, d] } } }; Uc.groupData = function (b, c, d, e) { var f = this, g = f.data, h = f.options.data, i = [], j = [], k = b.length, l, m, n, o = !!c, p = [], q = [], r = [], s = [], t = typeof e === "function" ? e : ad[e], u; for (u = 0; u <= k; u++) { while (d[1] !== a && b[u] >= d[1] || u === k) { l = d.shift(); n = t(p, q, r, s); if (n !== a) { i.push(l); j.push(n) } p = []; q = []; r = []; s = []; if (u === k) { break } } if (u === k) { break } m = o ? c[u] : null; if (e === "ohlc") { var v = f.cropStart + u, w = g && g[v] || f.pointClass.prototype.applyOptions.apply({}, [h[v]]), x = w.open, y = w.high, z = w.low, A = w.close; if (typeof x === Zc) { p.push(x) } else if (x === null) { p.hasNulls = true } if (typeof y === Zc) { q.push(y) } else if (y === null) { q.hasNulls = true } if (typeof z === Zc) { r.push(z) } else if (z === null) { r.hasNulls = true } if (typeof A === Zc) { s.push(A) } else if (A === null) { s.hasNulls = true } } else { if (typeof m === Zc) { p.push(m) } else if (m === null) { p.hasNulls = true } } } return [i, j] }; Uc.processData = function () { var a = this, b = a.options, c = b[Tc], d = c && c.enabled, e = a.groupedData, f; a.forceCrop = d; if (Vc.apply(a, arguments) === false || !d) { return } else { vb(e || [], function (a, b) { if (a) { e[b] = a.destroy ? a.destroy() : null } }) } var g, i = a.chart, j = a.processedXData, k = a.processedYData, l = i.plotSizeX, m = a.xAxis, n = Tb(m.groupPixelWidth, c.groupPixelWidth), o = j.length, p = i.series, q = a.pointRange; if (!m.groupPixelWidth) { g = p.length; while (g--) { if (p[g].xAxis === m && p[g].options[Tc]) { n = h(n, p[g].options[Tc].groupPixelWidth) } } m.groupPixelWidth = n } if (o > l / n || c.forced) { f = true; a.points = null; var r = m.getExtremes(), s = r.min, t = r.max, u = m.getGroupIntervalFactor && m.getGroupIntervalFactor(s, t, j) || 1, v = n * (t - s) / l * u, w = (m.getNonLinearTimeTicks || _b)($b(v, c.units || _c), s, t, null, j, a.closestPointRange), x = Uc.groupData.apply(a, [j, k, w, c.approximation]), y = x[0], z = x[1]; if (c.smoothed) { g = y.length - 1; y[g] = t; while (g-- && g > 0) { y[g] += v / 2 } y[0] = s } a.currentDataGrouping = w.info; if (b.pointRange === null) { a.pointRange = w.info.totalRange } a.closestPointRange = w.info.totalRange; a.processedXData = y; a.processedYData = z } else { a.currentDataGrouping = null; a.pointRange = q } a.hasGroupedData = f }; Uc.generatePoints = function () { var a = this; Wc.apply(a); a.groupedData = a.hasGroupedData ? a.points : null }; Uc.tooltipHeaderFormatter = function (a) { var b = this, c = b.options, d = b.tooltipOptions, e = c.dataGrouping, f = d.xDateFormat, g, h = b.xAxis, i, j, k, l, m, n; if (h && h.options.type === "datetime" && e) { i = b.currentDataGrouping; j = e.dateTimeLabelFormats; if (i) { k = j[i.unitName]; if (i.count === 1) { f = k[0] } else { f = k[1]; g = k[2] } } else if (!f) { for (m in G) { if (G[m] >= h.closestPointRange) { f = j[m][0]; break } } } l = D(f, a); if (g) { l += D(g, a + i.totalRange - 1) } n = d.headerFormat.replace("{point.key}", l) } else { n = Yc.apply(b, [a]) } return n }; Uc.destroy = function () { var a = this, b = a.groupedData || [], c = b.length; while (c--) { if (b[c]) { b[c].destroy() } } Xc.apply(a) }; uc.line[Tc] = uc.spline[Tc] = uc.area[Tc] = uc.areaspline[Tc] = $c; uc.column[Tc] = zb($c, { approximation: "sum", groupPixelWidth: 10 }); uc.ohlc = zb(uc.column, { lineWidth: 1, dataGrouping: { approximation: "ohlc", enabled: true, groupPixelWidth: 5 }, tooltip: { pointFormat: '<span style="color:{series.color};font-weight:bold">{series.name}</span><br/>' + "Open: {point.open}<br/>" + "High: {point.high}<br/>" + "Low: {point.low}<br/>" + "Close: {point.close}<br/>" }, states: { hover: { lineWidth: 3} }, threshold: null }); var bd = Wb(Ic, { applyOptions: function (b) { var c = this, d = c.series, e = 0; if (typeof b === "object" && typeof b.length !== "number") { Gb(c, b); c.options = b } else if (b.length) { if (b.length === 5) { if (typeof b[0] === "string") { c.name = b[0] } else if (typeof b[0] === "number") { c.x = b[0] } e++ } c.open = b[e++]; c.high = b[e++]; c.low = b[e++]; c.close = b[e++] } c.y = c.high; if (c.x === a && d) { c.x = d.autoIncrement() } return c } }); var cd = Wb(Fb.column, { type: "ohlc", valueCount: 4, pointClass: bd, pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, translate: function () { var a = this, b = a.yAxis; Fb.column.prototype.translate.apply(a); vb(a.points, function (a) { if (a.open !== null) { a.plotOpen = b.translate(a.open, 0, 1, 0, 1) } if (a.close !== null) { a.plotClose = b.translate(a.close, 0, 1, 0, 1) } }) }, drawPoints: function () { var b = this, c = b.points, d = b.chart, f, g, h, i, j, k, l, m; vb(c, function (c) { if (c.plotY !== a) { l = c.graphic; f = c.pointAttr[c.selected ? "selected" : ""]; i = f["stroke-width"] % 2 / 2; m = e(c.plotX) + i; j = e(c.barW / 2); k = ["M", m, e(c.yBottom), "L", m, e(c.plotY)]; if (c.open !== null) { g = e(c.plotOpen) + i; k.push("M", m, g, "L", m - j, g) } if (c.close !== null) { h = e(c.plotClose) + i; k.push("M", m, h, "L", m + j, h) } if (l) { l.animate({ d: k }) } else { c.graphic = d.renderer.path(k).attr(f).add(b.group) } } }) }, animate: null }); Fb.ohlc = cd; uc.candlestick = zb(uc.column, { dataGrouping: { approximation: "ohlc", enabled: true }, lineColor: "black", lineWidth: 1, states: { hover: { lineWidth: 2} }, tooltip: uc.ohlc.tooltip, threshold: null, upColor: "white" }); var dd = Wb(cd, { type: "candlestick", pointAttrToOptions: { fill: "color", stroke: "lineColor", "stroke-width": "lineWidth" }, getAttribs: function () { cd.prototype.getAttribs.apply(this, arguments); var a = this, b = a.options, c = b.states, d = b.upColor, e = zb(a.pointAttr); e[""].fill = d; e.hover.fill = c.hover.upColor || d; e.select.fill = c.select.upColor || d; vb(a.points, function (a) { if (a.open < a.close) { a.pointAttr = e } }) }, drawPoints: function () { var b = this, c = b.points, f = b.chart, g, h, i, j, k, l, m, n, o, p; vb(c, function (c) { n = c.graphic; if (c.plotY !== a) { g = c.pointAttr[c.selected ? "selected" : ""]; l = g["stroke-width"] % 2 / 2; m = e(c.plotX) + l; h = e(c.plotOpen) + l; i = e(c.plotClose) + l; j = d.min(h, i); k = d.max(h, i); p = e(c.barW / 2); o = ["M", m - p, k, "L", m - p, j, "L", m + p, j, "L", m + p, k, "L", m - p, k, "M", m, k, "L", m, e(c.yBottom), "M", m, j, "L", m, e(c.plotY), "Z"]; if (n) { n.animate({ d: o }) } else { c.graphic = f.renderer.path(o).attr(g).add(b.group) } } }) } }); Fb.candlestick = dd; var ed = Bc.prototype.symbols; uc.flags = zb(uc.column, { dataGrouping: null, fillColor: "white", lineWidth: 1, pointRange: 0, shape: "flag", stackDistance: 7, states: { hover: { lineColor: "black", fillColor: "#FCFFC5"} }, style: { fontSize: "11px", fontWeight: "bold", textAlign: "center" }, threshold: null, y: -30 }); Fb.flags = Wb(Fb.column, { type: "flags", sorted: false, noSharedTooltip: true, init: Jc.prototype.init, pointAttrToOptions: { fill: "fillColor", stroke: "color", "stroke-width": "lineWidth", r: "radius" }, translate: function () { Fb.column.prototype.translate.apply(this); var b = this, c = b.options, d = b.chart, e = b.points, f = e.length - 1, g, h, i = c.onSeries, j = i && d.get(i), k = j && j.options.step, l = j && j.points, m = l && l.length, n, o, p; if (j && j.visible && m) { o = l[m - 1].x; e.sort(function (a, b) { return a.x - b.x }); while (m-- && e[f]) { g = e[f]; n = l[m]; if (n.x <= g.x && n.plotY !== a) { if (g.x <= o) { g.plotY = n.plotY; if (n.x < g.x && !k) { p = l[m + 1]; if (p && p.plotY !== a) { g.plotY += (g.x - n.x) / (p.x - n.x) * (p.plotY - n.plotY) } } } f--; m++; if (f < 0) { break } } } } vb(e, function (b, c) { if (b.plotY === a) { b.plotY = d.plotHeight } h = e[c - 1]; if (h && h.plotX === b.plotX) { if (h.stackIndex === a) { h.stackIndex = 0 } b.stackIndex = h.stackIndex + 1 } }) }, drawPoints: function () { var b = this, c, d = b.points, e = b.chart, f = e.renderer, g, h, i = b.options, j = i.y, k = i.shape, l, m, n, o, p, q, r, s = i.lineWidth % 2 / 2, t, u; n = d.length; while (n--) { o = d[n]; g = o.plotX + s; r = o.stackIndex; h = o.plotY; if (h !== a) { h = o.plotY + j + s - (r !== a && r * i.stackDistance) } t = r ? a : o.plotX + s; u = r ? a : o.plotY; p = o.graphic; q = o.connector; if (h !== a) { c = o.pointAttr[o.selected ? "select" : ""]; if (p) { p.attr({ x: g, y: h, r: c.r, anchorX: t, anchorY: u }) } else { p = o.graphic = f.label(o.options.title || i.title || "A", g, h, k, t, u).css(zb(i.style, o.style)).attr(c).attr({ align: k === "flag" ? "left" : "center", width: i.width, height: i.height }).add(b.group).shadow(i.shadow) } l = p.box; m = l.getBBox(); o.shapeArgs = Gb(m, { x: g - (k === "flag" ? 0 : l.attr("width") / 2), y: h }) } else if (p) { o.graphic = p.destroy() } } }, drawTracker: function () { var a = this; Fb.column.prototype.drawTracker.apply(a); vb(a.points, function (a) { Ab(a.tracker.element, "mouseover", function () { a.graphic.toFront() }) }) }, tooltipFormatter: function (a) { return a.point.text }, animate: function () { } }); ed.flag = function (a, b, c, d, e) { var f = e && e.anchorX || a, g = e && e.anchorY || b; return ["M", f, g, "L", a, b + d, a, b, a + c, b, a + c, b + d, a, b + d, "M", f, g, "Z"] }; vb(["circle", "square"], function (a) { ed[a + "pin"] = function (b, c, d, e, f) { var g = f && f.anchorX, h = f && f.anchorY, i = ed[a](b, c, d, e); if (g && h) { i.push("M", g, c + e, "L", g, h) } return i } }); if (x === Cc) { vb(["flag", "circlepin", "squarepin"], function (a) { Cc.prototype.symbols[a] = ed[a] }) } var fd = y ? "touchstart" : "mousedown", gd = y ? "touchmove" : "mousemove", hd = y ? "touchend" : "mouseup"; var id = Hb(cb, { x1: 0, y1: 0, x2: 0, y2: 1 }, db, [[0, "#FFF"], [1, "#CCC"]]), jd = [].concat(_c); jd[4] = [Z, [1, 2, 3, 4]]; jd[5] = [$, [1, 2, 3]]; Gb(C, { navigator: { handles: { backgroundColor: "#FFF", borderColor: "#666" }, height: 40, margin: 10, maskFill: "rgba(255, 255, 255, 0.75)", outlineColor: "#444", outlineWidth: 1, series: { type: "areaspline", color: "#4572A7", compare: null, fillOpacity: .4, dataGrouping: { approximation: "average", groupPixelWidth: 2, smoothed: true, units: jd }, dataLabels: { enabled: false }, id: L + "navigator-series", lineColor: "#4572A7", lineWidth: 1, marker: { enabled: false }, pointRange: 0, shadow: false }, xAxis: { tickWidth: 0, lineWidth: 0, gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", x: 3, y: -4} }, yAxis: { gridLineWidth: 0, startOnTick: false, endOnTick: false, minPadding: .1, maxPadding: .1, labels: { enabled: false }, title: { text: null }, tickWidth: 0} }, scrollbar: { height: y ? 20 : 14, barBackgroundColor: id, barBorderRadius: 2, barBorderWidth: 1, barBorderColor: "#666", buttonArrowColor: "#666", buttonBackgroundColor: id, buttonBorderColor: "#666", buttonBorderRadius: 2, buttonBorderWidth: 1, rifleColor: "#666", trackBackgroundColor: Hb(cb, { x1: 0, y1: 0, x2: 0, y2: 1 }, db, [[0, "#EEE"], [1, "#FFF"]]), trackBorderColor: "#CCC", trackBorderWidth: 1} }); Highcharts.Scroller = function (a) { function db(a) { return f.top || a - E - G - c.chart.spacingBottom } function eb(a, c) { var d = { fill: D.backgroundColor, stroke: D.borderColor, "stroke-width": 1 }, e; if (!S) { Y[c] = b.g().css({ cursor: "e-resize" }).attr({ zIndex: 4 - c }).add(); e = b.rect(-4.5, 0, 9, 16, 3, 1).attr(d).add(Y[c]); cb.push(e); e = b.path(["M", -1.5, 4, "L", -1.5, 12, "M", .5, 4, "L", .5, 12]).attr(d).add(Y[c]); cb.push(e) } Y[c].translate(O + G + parseInt(a, 10), J + E / 2 - 8) } function fb(a) { var c; if (!S) { bb[a] = b.g().add(Z); c = b.rect(-.5, -.5, G + 1, G + 1, n.buttonBorderRadius, n.buttonBorderWidth).attr({ stroke: n.buttonBorderColor, "stroke-width": n.buttonBorderWidth, fill: n.buttonBackgroundColor }).add(bb[a]); cb.push(c); c = b.path(["M", G / 2 + (a ? -1 : 1), G / 2 - 3, "L", G / 2 + (a ? -1 : 1), G / 2 + 3, G / 2 + (a ? 2 : -2), G / 2]).attr({ fill: n.buttonArrowColor }).add(bb[a]); cb.push(c) } if (a) { bb[a].attr({ translateX: R - G }) } } function gb(c, d, l, m) { if (isNaN(c)) { return } var p, q = n.barBorderWidth, r; N = J + L; j = Tb(v.left, a.plotLeft + G); k = Tb(v.len, a.plotWidth - 2 * G); O = j - G; R = k + 2 * G; if (v.getExtremes) { var s = a.xAxis[0].getExtremes(), t = s.dataMin === null, u = v.getExtremes(), w = i(s.dataMin, u.dataMin), y = h(s.dataMax, u.dataMax); if (!t && (w !== u.min || y !== u.max)) { v.setExtremes(w, y, true, false) } } l = Tb(l, v.translate(c)); m = Tb(m, v.translate(d)); x = Ib(i(l, m)); z = Ib(h(l, m)); A = z - x; if (!S) { if (g) { V = b.rect().attr({ fill: f.maskFill, zIndex: 3 }).add(); W = b.rect().attr({ fill: f.maskFill, zIndex: 3 }).add(); X = b.path().attr({ "stroke-width": F, stroke: f.outlineColor, zIndex: 3 }).add() } if (o) { Z = b.g().add(); p = n.trackBorderWidth; $ = b.rect().attr({ y: -p % 2 / 2, fill: n.trackBackgroundColor, stroke: n.trackBorderColor, "stroke-width": p, r: n.trackBorderRadius || 0, height: G }).add(Z); _ = b.rect().attr({ y: -q % 2 / 2, height: G, fill: n.barBackgroundColor, stroke: n.barBorderColor, "stroke-width": q, r: I }).add(Z); ab = b.path().attr({ stroke: n.rifleColor, "stroke-width": 1 }).add(Z) } } if (g) { V.attr({ x: j, y: J, width: x, height: E }); W.attr({ x: j + z, y: J, width: k - z, height: E }); X.attr({ d: [P, O, N, Q, j + x + L, N, j + x + L, N + H - G, P, j + z - L, N + H - G, Q, j + z - L, N, O + R, N] }); eb(x + L, 0); eb(z + L, 1) } if (o) { fb(0); fb(1); Z.translate(O, e(N + E)); $.attr({ width: R }); _.attr({ x: e(G + x) + q % 2 / 2, width: A - q }); r = G + x + A / 2 - .5; ab.attr({ d: [P, r - 3, G / 4, Q, r - 3, 2 * G / 3, P, r, G / 4, Q, r, 2 * G / 3, P, r + 3, G / 4, Q, r + 3, 2 * G / 3], visibility: A > 12 ? M : K }) } S = true } function hb(b) { b = a.tracker.normalizeMouseEvent(b); var c = b.chartX, e = b.chartY, f = y ? 10 : 7, g, h; if (e > J && e < J + E + G) { h = !o || e < J + E; if (h && d.abs(c - x - j) < f) { p = true; s = z } else if (h && d.abs(c - z - j) < f) { q = true; s = x } else if (c > j + x && c < j + z) { r = c; C = B.cursor; B.cursor = "ew-resize"; t = c - x } else if (c > O && c < O + R) { if (h) { g = c - j - A / 2 } else { if (c < j) { g = x - i(10, A) } else if (c > O + R - G) { g = x + i(10, A) } else { g = c < j + x ? x - A : z } } if (g < 0) { g = 0 } else if (g + A > k) { g = k - A } if (g !== x) { a.xAxis[0].setExtremes(v.translate(g, true), v.translate(g + A, true), true, false) } } } } function ib(b) { b = a.tracker.normalizeMouseEvent(b); var c = b.chartX; if (c < j) { c = j } else if (c > O + R - G) { c = O + R - G } if (p) { u = true; gb(0, 0, c - j, s) } else if (q) { u = true; gb(0, 0, s, c - j) } else if (r) { u = true; if (c < t) { c = t } else if (c > k + t - A) { c = k + t - A } gb(0, 0, c - t, c - t + A) } } function jb() { if (u) { a.xAxis[0].setExtremes(v.translate(x, true), v.translate(z, true), true, false) } p = q = r = u = t = null; B.cursor = C } function kb() { var b = U.xAxis, c = b.getExtremes(), d = c.min, e = c.max, f = c.dataMin, g = c.dataMax, j = e - d, k, n, o, p, q, r = l.xData, s = !!b.setExtremes; n = e >= r[r.length - 1]; k = d <= f; if (!m) { l.options.pointStart = U.xData[0]; l.setData(U.options.data, false); q = true } if (k) { p = f; o = p + j } if (n) { o = g; if (!k) { p = h(o - j, l.xData[0]) } } if (s && (k || n)) { b.setExtremes(p, o, true, false) } else { if (q) { a.redraw(false) } gb(h(d, f), i(e, g)) } } function lb() { Ab(a.container, fd, hb); Ab(a.container, gd, ib); Ab(document, hd, jb) } function mb() { Bb(a.container, fd, hb); Bb(a.container, gd, ib); Bb(document, hd, jb); if (g) { Bb(U, "updatedData", kb) } } function nb() { var b = a.xAxis.length, c = a.yAxis.length, d = a.setSize; a.extraBottomMargin = H + f.margin; J = db(a.chartHeight); if (g) { var e = U.options, h, i = e.data, j = f.series; m = j.data; e.data = j.data = null; v = new a.Axis(zb({ ordinal: U.xAxis.options.ordinal }, f.xAxis, { isX: true, type: "datetime", index: b, height: E, top: J, offset: 0, offsetLeft: G, offsetRight: -G, startOnTick: false, endOnTick: false, minPadding: 0, maxPadding: 0, zoomEnabled: false })); w = new a.Axis(zb(f.yAxis, { alignTicks: false, height: E, top: J, offset: 0, index: c, zoomEnabled: false })); h = zb(U.options, j, { threshold: null, clip: false, enableMouseTracking: false, group: "nav", padXAxis: false, xAxis: b, yAxis: c, name: "Navigator", showInLegend: false, isInternal: true, visible: true }); e.data = i; j.data = m; h.data = m || i; l = a.initSeries(h); Ab(U, "updatedData", kb) } else { v = { translate: function (b, c) { var d = a.xAxis[0].getExtremes(), e = a.plotWidth - 2 * G, f = d.dataMin, g = d.dataMax - f; return c ? b * g / e + f : e * (b - f) / g } } } a.setSize = function (b, c, e) { v.options.top = w.options.top = J = db(c); d.call(a, b, c, e) }; lb() } function ob() { mb(); vb([v, w, V, W, X, $, _, ab, Z], function (a) { if (a && a.destroy) { a.destroy() } }); v = w = V = W = X = $ = _ = ab = Z = null; vb([bb, Y, cb], function (a) { fc(a) }) } var b = a.renderer, c = a.options, f = c.navigator, g = f.enabled, j, k, l, m, n = c.scrollbar, o = n.enabled, p, q, r, s, t, u, v, w, x, z, A, B = document.body.style, C, D = f.handles, E = g ? f.height : 0, F = f.outlineWidth, G = o ? n.height : 0, H = E + G, I = n.barBorderRadius, J, L = F / 2, N, O, R, S, T = f.baseSeries, U = a.series[T] || typeof T === "string" && a.get(T) || a.series[0], V, W, X, Y = [], Z, $, _, ab, bb = [], cb = []; a.resetZoomEnabled = false; nb(); return { render: gb, destroy: ob, series: l, xAxis: v, yAxis: w} }; Gb(C, { rangeSelector: { buttonTheme: { width: 28, height: 16, padding: 1, r: 0, zIndex: 10}} }); C.lang = zb(C.lang, { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "From:", rangeSelectorTo: "To:" }); Highcharts.RangeSelector = function (b) { function u(a, c, d) { var e = b.xAxis[0], f = e && e.getExtremes(), g = b.scroller && b.scroller.xAxis, j = g && g.getExtremes && g.getExtremes(), k = j && j.dataMin, l = j && j.dataMax, m = f && f.dataMin, n = f && f.dataMax, p = i(m, Tb(k, m)), r = h(n, Tb(l, n)), s, t = e && i(f.max, r), u, v = new Date(t), w = c.type, x = c.count, y, z, A, B, C = { millisecond: 1, second: 1e3, minute: 60 * 1e3, hour: 3600 * 1e3, day: 24 * 3600 * 1e3, week: 7 * 24 * 3600 * 1e3 }; if (p === null || r === null || a === o) { return } if (C[w]) { z = C[w] * x; s = h(t - z, p) } else if (w === "month") { v.setMonth(v.getMonth() - x); s = h(v.getTime(), p); z = 30 * 24 * 3600 * 1e3 * x } else if (w === "ytd") { v = new Date(0); u = new Date(r); B = u.getFullYear(); v.setFullYear(B); if (String(B) !== D("%Y", v)) { v.setFullYear(B - 1) } s = A = h(p || 0, v.getTime()); u = u.getTime(); t = i(r || u, u) } else if (w === "year") { v.setFullYear(v.getFullYear() - x); s = h(p, v.getTime()); z = 365 * 24 * 3600 * 1e3 * x } else if (w === "all" && e) { s = p; t = r } if (q[a]) { var E; for (E = 0; E < q.length; E++) { q[E].setState(0) } q[a].setState(2) } if (!e) { y = b.options.xAxis; y[0] = zb(y[0], { range: z, min: A }); o = a } else { setTimeout(function () { e.setExtremes(s, t, Tb(d, 1), 0, { rangeSelectorButton: c }); o = a }, 1) } } function v() { if (j) { j.blur() } if (k) { k.blur() } } function w() { b.extraTopMargin = 25; s = b.options.rangeSelector; r = s.buttons || t; var c = s.selected; Ab(e, fd, v); if (c !== a && r[c]) { u(c, r[c], false) } Ab(b, "load", function () { Ab(b.xAxis[0], "afterSetExtremes", function () { if (this.isDirty) { if (q[o]) { q[o].setState(0) } o = null } }) }) } function x(a, b) { var c = a.hasFocus ? s.inputEditDateFormat || "%Y-%m-%d" : s.inputDateFormat || "%b %e, %Y"; if (b) { a.HCTime = b } a.value = D(c, a.HCTime) } function y(a) { var c = a === "min", d; l[a] = Vb("span", { innerHTML: f[c ? "rangeSelectorFrom" : "rangeSelectorTo"] }, s.labelStyle, g); d = Vb("input", { name: a, className: L + "range-selector", type: "text" }, Gb({ width: "80px", height: "16px", border: "1px solid silver", marginLeft: "5px", marginRight: c ? "5px" : "0", textAlign: "center" }, s.inputStyle), g); d.onfocus = d.onblur = function (a) { a = a || window.event; d.hasFocus = a.type === "focus"; x(d) }; d.onchange = function () { var a = d.value, e = Date.parse(a), f = b.xAxis[0].getExtremes(); if (isNaN(e)) { e = a.split("-"); e = Date.UTC(Ib(e[0]), Ib(e[1]) - 1, Ib(e[2])) } if (!isNaN(e) && (c && e >= f.dataMin && e <= k.HCTime || !c && e <= f.dataMax && e >= j.HCTime)) { b.xAxis[0].setExtremes(c ? e : f.min, c ? f.max : e) } }; return d } function z(a, h) { var i = b.options.chart.style, l = s.buttonTheme, t = s.inputEnabled !== false, v = l && l.states, w = b.plotLeft, z; if (!d) { p = c.text(f.rangeSelectorZoom, w, b.plotTop - 10).css(s.labelStyle).add(); z = w + p.getBBox().width + 5; vb(r, function (a, d) { q[d] = c.button(a.text, z, b.plotTop - 25, function () { u(d, a); this.isActive = true }, l, v && v.hover, v && v.select).css({ textAlign: "center" }).add(); z += q[d].width + (s.buttonSpacing || 0); if (o === d) { q[d].setState(2) } }); if (t) { n = g = Vb("div", null, { position: "relative", height: 0, fontFamily: i.fontFamily, fontSize: i.fontSize, zIndex: 1 }); e.parentNode.insertBefore(g, e); m = g = Vb("div", null, Gb({ position: "absolute", top: b.plotTop - 25 + "px", right: b.chartWidth - b.plotLeft - b.plotWidth + "px" }, s.inputBoxStyle), g); j = y("min"); k = y("max") } } if (t) { x(j, a); x(k, h) } d = true } function A() { Bb(e, fd, v); vb([q], function (a) { fc(a) }); if (p) { p = p.destroy() } if (j) { j.onfocus = j.onblur = j.onchange = null } if (k) { k.onfocus = k.onblur = k.onchange = null } vb([j, k, l.min, l.max, m, n], function (a) { gc(a) }); j = k = l = g = m = n = null } var c = b.renderer, d, e = b.container, f = C.lang, g, j, k, l = {}, m, n, o, p, q = [], r, s, t = [{ type: "month", count: 1, text: "1m" }, { type: "month", count: 3, text: "3m" }, { type: "month", count: 6, text: "6m" }, { type: "ytd", text: "YTD" }, { type: "year", count: 1, text: "1y" }, { type: "all", text: "All"}]; b.resetZoomEnabled = false; w(); return { render: z, destroy: A} }; Hc.prototype.callbacks.push(function (a) { function e() { b = a.xAxis[0].getExtremes(); c.render(h(b.min, b.dataMin), i(b.max, b.dataMax)) } function f() { b = a.xAxis[0].getExtremes(); d.render(b.min, b.max) } function g(a) { c.render(a.min, a.max) } function j(a) { d.render(a.min, a.max) } function k() { if (c) { Bb(a, "resize", e); Bb(a.xAxis[0], "afterSetExtremes", g) } if (d) { Bb(a, "resize", f); Bb(a.xAxis[0], "afterSetExtremes", j) } } var b, c = a.scroller, d = a.rangeSelector; if (c) { Ab(a.xAxis[0], "afterSetExtremes", g); Ab(a, "resize", e); e() } if (d) { Ab(a.xAxis[0], "afterSetExtremes", j); Ab(a, "resize", f); f() } Ab(a, "destroy", k) }); Highcharts.StockChart = function (a, b) { var c = a.series, d, e = { marker: { enabled: false, states: { hover: { enabled: true, radius: 5}} }, shadow: false, states: { hover: { lineWidth: 2} }, dataGrouping: { enabled: true} }; a.xAxis = yb(Sb(a.xAxis || {}), function (a) { return zb({ minPadding: 0, maxPadding: 0, ordinal: true, title: { text: null }, showLastLabel: true }, a, { type: "datetime", categories: null }) }); a.yAxis = yb(Sb(a.yAxis || {}), function (a) { d = a.opposite; return zb({ labels: { align: d ? "right" : "left", x: d ? -2 : 2, y: -2 }, showLastLabel: false, title: { text: null} }, a) }); a.series = null; a = zb({ chart: { panning: true }, navigator: { enabled: true }, scrollbar: { enabled: true }, rangeSelector: { enabled: true }, title: { text: null }, tooltip: { shared: true, crosshairs: true }, legend: { enabled: false }, plotOptions: { line: e, spline: e, area: e, areaspline: e, column: { shadow: false, borderWidth: 0, dataGrouping: { enabled: true}}} }, a, { chart: { inverted: false} }); a.series = c; return new Hc(a, b) }; var kd = Uc.init, ld = Uc.processData, md = Ic.prototype.tooltipFormatter; Uc.init = function () { kd.apply(this, arguments); var a = this, b = a.options.compare; if (b) { a.modifyValue = function (a, c) { var d = this.compareValue; a = b === "value" ? a - d : a = 100 * (a / d) - 100; if (c) { c.change = a } return a } } }; Uc.processData = function () { var a = this; ld.apply(this, arguments); if (a.options.compare) { var b = 0, c = a.processedXData, d = a.processedYData, e = d.length, f = a.xAxis.getExtremes().min; for (; b < e; b++) { if (typeof d[b] === Zc && c[b] >= f) { a.compareValue = d[b]; break } } } }; Ic.prototype.tooltipFormatter = function (a) { var b = this; a = a.replace("{point.change}", (b.change > 0 ? "+" : "") + Xb(b.change, b.series.tooltipOptions.changeDecimals || 2)); return md.apply(this, [a]) }; (function () { var b = Uc.init, c = Uc.getSegments; Uc.init = function () { var c = this, d, e; b.apply(c, arguments); d = c.chart; e = c.xAxis; if (e && e.options.ordinal) { Ab(c, "updatedData", function () { delete e.ordinalIndex }) } if (e && e.options.ordinal && !e.hasOrdinalExtension) { e.hasOrdinalExtension = true; e.beforeSetTickPositions = function () { var b = this, c, d = [], f = false, g, h = b.getExtremes(), i = h.min, j = h.max, k, l, m, n; if (b.options.ordinal) { vb(b.series, function (a, b) { if (a.visible !== false) { d = d.concat(a.processedXData); c = d.length; if (b && c) { d.sort(function (a, b) { return a - b }); b = c - 1; while (b--) { if (d[b] === d[b + 1]) { d.splice(b, 1) } } } } }); c = d.length; if (c > 2) { g = d[1] - d[0]; n = c - 1; while (n-- && !f) { if (d[n + 1] - d[n] !== g) { f = true } } } if (f) { b.ordinalPositions = d; k = e.val2lin(i, true); l = e.val2lin(j, true); b.ordinalSlope = m = (j - i) / (l - k); b.ordinalOffset = i - k * m } else { b.ordinalPositions = b.ordinalSlope = b.ordinalOffset = a } } }; e.val2lin = function (a, b) { var c = this, d = c.ordinalPositions; if (!d) { return a } else { var e = d.length, f, g, h; f = e; while (f--) { if (d[f] === a) { h = f; break } } f = e - 1; while (f--) { if (a > d[f] || f === 0) { g = (a - d[f]) / (d[f + 1] - d[f]); h = f + g; break } } return b ? h : c.ordinalSlope * (h || 0) + c.ordinalOffset } }; e.lin2val = function (b, c) { var d = this, e = d.ordinalPositions; if (!e) { return b } else { var g = d.ordinalSlope, h = d.ordinalOffset, i = e.length - 1, j, k, l; if (c) { if (b < 0) { b = e[0] } else if (b > i) { b = e[i] } else { i = f(b); l = b - i } } else { while (i--) { j = g * i + h; if (b >= j) { k = g * (i + 1) + h; l = (b - j) / (k - j); break } } } return l !== a && e[i] !== a ? e[i] + (l ? l * (e[i + 1] - e[i]) : 0) : b } }; e.getExtendedPositions = function () { var a = e.series[0].currentDataGrouping, b = e.ordinalIndex, c = a ? a.count + a.unitName : "raw", f = e.getExtremes(), g, h; if (!b) { b = e.ordinalIndex = {} } if (!b[c]) { g = { series: [], getExtremes: function () { return { min: f.dataMin, max: f.dataMax} }, options: { ordinal: true} }; vb(e.series, function (b) { h = { xAxis: g, xData: b.xData, chart: d }; h.options = { dataGrouping: a ? { enabled: true, forced: true, approximation: "open", units: [[a.unitName, [a.count]]]} : { enabled: false} }; b.processData.apply(h); g.series.push(h) }); e.beforeSetTickPositions.apply(g); b[c] = g.ordinalPositions } return b[c] }; e.getGroupIntervalFactor = function (a, b, c) { var d = 0, e = c.length, g = [], h; for (; d < e - 1; d++) { g[d] = c[d + 1] - c[d] } g.sort(function (a, b) { return a - b }); h = g[f(e / 2)]; return e * h / (b - a) }; e.postProcessTickInterval = function (a) { var b = this.ordinalSlope; return b ? a / (b / e.closestPointRange) : a }; e.getNonLinearTimeTicks = function (b, c, d, g, h, i, j) { var k = 0, l = 0, m, n = {}, o, p, q, r, s = [], t = e.options.tickPixelInterval; if (!h || c === a) { return _b(b, c, d, g) } q = h.length; for (; l < q; l++) { r = l && h[l - 1] > d; if (h[l] < c) { k = l } if (l === q - 1 || h[l + 1] - h[l] > i * 5 || r) { m = _b(b, h[k], h[l], g); s = s.concat(m); k = l + 1 } if (r) { break } } p = m.info; if (j && p.unitRange <= G[Y]) { l = s.length - 1; for (k = 1; k < l; k++) { if ((new Date(s[k]))[kb]() !== (new Date(s[k - 1]))[kb]()) { n[s[k]] = Z; o = true } } if (o) { n[s[0]] = Z } p.higherRanks = n } s.info = p; if (j && Qb(t)) { var u = s.length, v = u, w, x, y = [], z, A, B, C = []; while (v--) { x = e.translate(s[v]); if (z) { C[v] = z - x } y[v] = z = x } C.sort(); A = C[f(C.length / 2)]; if (A < t * .6) { A = null } v = s[u - 1] > d ? u - 1 : u; z = undefined; while (v--) { x = y[v]; B = z - x; if (z && B < t * .8 && (A === null || B < A * .8)) { if (n[s[v]] && !n[s[v + 1]]) { w = v + 1; z = x } else { w = v } s.splice(w, 1) } else { z = x } } } return s }; var g = d.pan; d.pan = function (a) { var b = d.xAxis[0], c = false; if (b.options.ordinal) { var e = d.mouseDownX, f = b.getExtremes(), k = f.dataMax, l = f.min, m = f.max, n, o, p = d.hoverPoints, q = b.closestPointRange, r = b.translationSlope * (b.ordinalSlope || q), s = (e - a) / r, t = { ordinalPositions: b.getExtendedPositions() }, u, v, w = b.lin2val, x = b.val2lin, y; if (!t.ordinalPositions) { c = true } else if (j(s) > 1) { if (p) { vb(p, function (a) { a.setState() }) } if (s < 0) { v = t; y = b.ordinalPositions ? b : t } else { v = b.ordinalPositions ? b : t; y = t } u = y.ordinalPositions; if (k > u[u.length - 1]) { u.push(k) } n = w.apply(v, [x.apply(v, [l, true]) + s, true]); o = w.apply(y, [x.apply(y, [m, true]) + s, true]); if (n > i(f.dataMin, l) && o < h(k, m)) { b.setExtremes(n, o, true, false) } d.mouseDownX = a; Ub(d.container, { cursor: "move" }) } } else { c = true } if (c) { g.apply(d, arguments) } } } }; Uc.getSegments = function () { var a = this, b, d = a.options.gapSize; c.apply(a); if (a.xAxis.options.ordinal && d) { b = a.segments; vb(b, function (c, e) { var f = c.length - 1; while (f--) { if (c[f + 1].x - c[f].x > a.xAxis.closestPointRange * d) { b.splice(e + 1, 0, c.splice(f + 1, c.length - f)) } } }) } } })(); Gb(Highcharts, { Chart: Hc, dateFormat: D, pathAnim: F, getOptions: yc, hasBidiBug: v, numberFormat: Xb, Point: Ic, Color: zc, Renderer: x, SVGRenderer: Bc, VMLRenderer: Cc, CanVGRenderer: Fc, seriesTypes: Fb, setOptions: xc, Series: Jc, addEvent: Ab, removeEvent: Bb, createElement: Vb, discardElement: gc, css: Ub, each: vb, extend: Gb, map: yb, merge: zb, pick: Tb, splat: Sb, extendClass: Wb, placeBox: bc, product: "Highstock", version: "1.1.5" }) })()